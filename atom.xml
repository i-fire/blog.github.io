<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fire&#39;s Blog</title>
  
  <subtitle>念念不忘，必有回响</subtitle>
  <link href="https://i-fire.top/atom.xml" rel="self"/>
  
  <link href="https://i-fire.top/"/>
  <updated>2021-03-21T07:05:47.182Z</updated>
  <id>https://i-fire.top/</id>
  
  <author>
    <name>烟火小兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树，森林，二叉树的转换</title>
    <link href="https://i-fire.top/post/tranformTree.html"/>
    <id>https://i-fire.top/post/tranformTree.html</id>
    <published>2021-03-21T06:56:58.000Z</published>
    <updated>2021-03-21T07:05:47.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树，森林，二叉树的转换"><a href="#树，森林，二叉树的转换" class="headerlink" title="树，森林，二叉树的转换"></a>树，森林，二叉树的转换</h1><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将一颗普通的树转换为二叉树需要如下的几步</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321140249.png"></p><ul><li>树中所有的双亲节点的兄弟节点之间加一条连线</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321140334.png"></p><ul><li>对树中不是双亲节点的第一个孩子的节点，只保留新添加的该结点与左兄弟结点之间的连线，删去该结点与双亲结点之间的连线</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321140502.png"></p><ul><li>整理所有保留和添加的的连线，使每个结点的第一个孩子结点连线位于左孩子指针位置，使每个结点的右兄弟结点连线位于右孩子指针</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321140543.png"></p><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>森林：森林指的是由n(n&gt;=2)棵互不相交的树组成的集合</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321141148.png"></p><p>由于任何一颗树都可以转换为一棵二叉树，而森林是由多个普通树构成的，因此自然可以转化为二叉树，将森林转换为二叉树需要进行如下的几步</p><ul><li>首先将森林中的树各自都转换为二叉树</li><li>第一棵树不动，从第二棵二叉树开始，一次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连接起来，当所有的二叉树连接起来后就得到了由森林转换而来的二叉树<img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321142126.png"></li></ul><h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><p>将二叉树转化为一棵普通的树需要如下的几步</p><ul><li>若某一个节点X的左孩子节点存在，那么就将X节点的右孩子节点，右孩子节点的右孩子节点，以此类推，都作为X节点的孩子，将他们用线连接起来</li><li>删除<strong>原二叉树</strong>中所有节点和其右孩子节点的连线，整理得到的树即为所要求的树</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321144427.png"></p><h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><p>将一棵二叉树转换为森林需要满足一个条件：<strong>这棵二叉树必须要有右孩子</strong></p><ul><li><p>从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。</p></li><li><p>将每棵分离后的二叉树转换为树。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321145324.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树，森林，二叉树的转换&quot;&gt;&lt;a href=&quot;#树，森林，二叉树的转换&quot; class=&quot;headerlink&quot; title=&quot;树，森林，二叉树的转换&quot;&gt;&lt;/a&gt;树，森林，二叉树的转换&lt;/h1&gt;&lt;h3 id=&quot;树转换为二叉树&quot;&gt;&lt;a href=&quot;#树转换为二叉树&quot; c</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>普通树的表示</title>
    <link href="https://i-fire.top/post/displayTree.html"/>
    <id>https://i-fire.top/post/displayTree.html</id>
    <published>2021-03-21T00:54:42.000Z</published>
    <updated>2021-03-21T07:05:34.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h1><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321074217.png"></p><p>如图所示这是一个普通的树，这样的树该如何进行存储？？？<br>存储这样的树通常有三种方式</p><ul><li>双亲表示法</li><li>孩子表示法</li><li>兄弟表示法</li></ul><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>树的双亲表示法采用数组结构存储树，其实现的核心思想是：顺序存储各个节点的同时，给各节点增加一个记录父节点位置的变量</p><blockquote><p>注意，根节点没有父节点（父节点又称为双亲节点），因此根节点记录父节点位置的变量通常置为 -1。</p></blockquote><p>例如，采用双亲表示法存储图 1 中普通树，其存储状态如图 2 所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321074923.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;<span class="comment">//宏定义树结构中数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Snode</span>  //结点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  //树结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNode tnode[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;                 <span class="comment">//结点个数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="function">PTree <span class="title">InitPNode</span><span class="params">(PTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输出节点个数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(tree.n));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入结点的值其双亲位于数组中的位置下标:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;tree.n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>,&amp;ch,&amp;j);</span><br><span class="line">        tree.tnode[i].data = ch;</span><br><span class="line">        tree.tnode[i].parent = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindParent</span><span class="params">(PTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> isfind = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查询的结点值:\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;tree.n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree.tnode[i].data == a)&#123;</span><br><span class="line">            isfind=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ad=tree.tnode[i].parent;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c的父节点为 %c,存储位置下标为 %d&quot;</span>,a,tree.tnode[ad].data,ad);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isfind == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;树中无此节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PTree tree;</span><br><span class="line">    tree = InitPNode(tree);</span><br><span class="line">    FindParent(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>孩子表示法存储普通树采用的是 “顺序表+链表” 的组合结构，其存储过程是：从树的根节点开始，使用顺序表依次存储树中各个节点，需要注意的是，与双亲表示法不同，孩子表示法会给各个节点配备一个链表，用于存储各节点的孩子节点位于顺序表中的位置</p><blockquote><p>如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321081456.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TElemType char</span></span><br><span class="line"><span class="comment">//孩子表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//链表中每个结点存储的不是数据本身，而是数据在数组中存储的位置下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//结点的数据类型</span></span><br><span class="line">    ChildPtr* firstchild;<span class="comment">//孩子链表的头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_SIZE];<span class="comment">//存储结点的数组</span></span><br><span class="line">    <span class="keyword">int</span> n,r;<span class="comment">//结点数量和树根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"><span class="comment">//孩子表示法存储普通树</span></span><br><span class="line"><span class="function">CTree <span class="title">initTree</span><span class="params">(CTree tree)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入节点数量：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(tree.n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree.n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第 %d 个节点的值：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;(tree.nodes[i].data));</span><br><span class="line">        tree.nodes[i].firstchild=(ChildPtr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ChildPtr));</span><br><span class="line">        tree.nodes[i].firstchild-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入节点 %c 的孩子节点数量：\n&quot;</span>,tree.nodes[i].data);</span><br><span class="line">        <span class="keyword">int</span> Num;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Num);</span><br><span class="line">        <span class="keyword">if</span>(Num!=<span class="number">0</span>)&#123;</span><br><span class="line">            ChildPtr * p = tree.nodes[i].firstchild;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;Num;j++)&#123;</span><br><span class="line">                ChildPtr * newEle=(ChildPtr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ChildPtr));</span><br><span class="line">                newEle-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入第 %d 个孩子节点在顺序表中的位置&quot;</span>,j+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(newEle-&gt;child));</span><br><span class="line">                p-&gt;next= newEle;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findKids</span><span class="params">(CTree tree,<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hasKids=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree.n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree.nodes[i].data==a)&#123;</span><br><span class="line">            ChildPtr * p=tree.nodes[i].firstchild-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                hasKids = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,tree.nodes[p-&gt;child].data);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasKids==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;此节点为叶子节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTree tree;</span><br><span class="line">    tree = initTree(tree);</span><br><span class="line">    <span class="comment">//默认数根节点位于数组notes[0]处</span></span><br><span class="line">    tree.r=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找出节点 F 的所有孩子节点：&quot;</span>);</span><br><span class="line">    findKids(tree,<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用孩子表示法存储的树结构，正好和双亲表示法相反，适用于查找某结点的孩子结点，不适用于查找其父结点。<br>其实，我们还可以将双亲表示法和孩子表示法合二为一，那么图 1a) 中普通树的存储效果如图 2所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321081639.png"></p><p>使用图 2 结构存储普通树，既能快速找到指定节点的父节点，又能快速找到指定节点的孩子节点。</p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>树结构中，位于同一层的节点之间互为兄弟节点。例如，图 1 的普通树中，节点 A、B 和 C 互为兄弟节点，而节点 D、E 和 F 也互为兄弟节点。<br>孩子兄弟表示法，采用的是链式存储结构，其存储树的实现思想是：从树的根节点开始，依次用链表存储各个节点的孩子节点和兄弟节点。因此，该链表中的节点应包含以下 3 部分内容（如图 2 所示）：</p><ol><li>节点的值；</li><li>指向孩子节点的指针；</li><li>指向兄弟节点的指针；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321084749.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType char</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> * <span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210321084846.png"></p><p>接下来观察图 1 和图 3。图 1 为原普通树，图 3 是由图 1 经过孩子兄弟表示法转化而来的一棵树，确切地说，图 3 是一棵<a href="http://data.biancheng.net/view/192.html">二叉树</a>。因此可以得出这样一个结论，即通过孩子兄弟表示法，任意一棵普通树都可以相应转化为一棵二叉树，换句话说，任意一棵普通树都有唯一的一棵二叉树于其对应。</p><blockquote><p>因此，孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为”二叉树表示法”或”二叉链表表示法”。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的表示&quot;&gt;&lt;a href=&quot;#树的表示&quot; class=&quot;headerlink&quot; title=&quot;树的表示&quot;&gt;&lt;/a&gt;树的表示&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线索二叉树</title>
    <link href="https://i-fire.top/post/threadBinaryTree.html"/>
    <id>https://i-fire.top/post/threadBinaryTree.html</id>
    <published>2021-03-20T23:02:03.000Z</published>
    <updated>2021-03-20T23:04:02.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210320074947.png"></p><p>如果算法中涉及到多次遍历二叉树，普通的二叉树就要使用<strong>栈</strong>结构进行重复的操作，但是线索二叉树不需要如此，在遍历的时候，使用二叉树中空闲的内存空间记录某些节点的前驱和后继的位置（不是全部），这样在后期遍历二叉树的时候可以利用保存的节点信息，提高遍历的效率，这样构建出来的二叉树称为<strong>线索二叉树</strong></p><h3 id="线索二叉树的结构特点"><a href="#线索二叉树的结构特点" class="headerlink" title="线索二叉树的结构特点"></a>线索二叉树的结构特点</h3><p>如果想要在线索二叉树中保存节点的前驱和后继的指针，最简单的方法就是再添加两个指针域，分别指向该节点的前驱和后继，但是这样会降低二叉树的存储密度，同时二叉树本身还有很多的空间没有使用<br><strong>线索二叉树实际上就是利用二叉树中空指针域来存储节点之间的前驱和后继关系的一种特殊的二叉树</strong><br>在线索二叉树中，如果节点有左子树，那么lchild就存储的是左子树的地址，否则lchild存储的就是该节点的直接前驱，如果节点有右子树，那么rchild存储的就是右子树的地址，否则rchild存储的就是该节点的直接后继<br>为了防止指针域指向的节点的意义混淆，我们还需要设立两个标志位用来区分指针域的意义</p><ul><li>ltag：当ltag的值为0时，lchild指向的应该是节点的左子树，反之，当ltag为1时，lchild指向的应该是节点的直接前驱</li><li>rtag：当rtag的值为0时，rchild指向的应该是节点的右子树，反之，当rtag为1时，rchild指向的应该是节点的直接后继</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210320081408.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;<span class="comment">//两个标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//两个指针域</span></span><br><span class="line">&#125; threadBinaryTree;</span><br></pre></td></tr></table></figure><p>表示二叉树时，使用图二所示的节点构成的二叉链表被称为<strong>线索链表</strong>，构建的二叉树被称为<strong>线索二叉树</strong></p><blockquote><p>线索链表中的“线索”，指的是链表中指向结点前趋和后继的指针。二叉树经过某种遍历方法转化为线索二叉树的过程称为线索化</p></blockquote><h3 id="二叉树中序遍历线索化"><a href="#二叉树中序遍历线索化" class="headerlink" title="二叉树中序遍历线索化"></a>二叉树中序遍历线索化</h3><p>将二叉树转化为线索二叉树，实质上是在遍历二叉树的过程中，将二叉链表中的空指针改为指向直接前趋或者直接后继的线索在遍历过程中，如果当前结点没有左孩子，需要将该结点的 lchild 指针指向遍历过程中的前一个结点，所以在遍历过程中，设置一个指针（名为 pre ）， 时刻指向当前访问结点的前一个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Link, Thread</span><br><span class="line">&#125; PointerTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据为</span></span><br><span class="line">    PointerTag ltag;</span><br><span class="line">    PointerTag rtag;<span class="comment">//两个标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//两个指针域</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiTNode *pre = <span class="literal">NULL</span>;<span class="comment">//用pre来记录二叉树节点的前驱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiTree root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree biTree;</span><br><span class="line">    createBiTree(&amp;biTree);</span><br><span class="line">    InThreading(biTree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    *T = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"></span><br><span class="line">    (*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InThreading(T-&gt;lchild);</span><br><span class="line">        <span class="comment">//如果当前节点没有左孩子，那么就将ltag设置为1，左孩子指针指向上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (!T-&gt;lchild) &#123;</span><br><span class="line">            T-&gt;lchild = pre;</span><br><span class="line">            T-&gt;ltag = Thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre没有右孩子，那么就将rtag设置为1，右孩子指针指向上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; !pre-&gt;rchild) &#123;<span class="comment">//说明，这里的pre保存的是当前二叉树节点的前驱，如果这个前驱，没有右孩子节点，说明T就是pre的后继</span></span><br><span class="line">            pre-&gt;rchild = T;</span><br><span class="line">            pre-&gt;rtag = Thread;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = T;</span><br><span class="line">        InThreading(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210320153957.png"></p><p>当我们使用线索二叉树的时候，常常会碰到这样的问题，在图3中，b节点的直接后继是通过指针域直接获得的，也就是节点‘*’，但是因为节点“<em>”的度为2，因此无法得到节点“\</em>”的后继节点，这样的话整个链表就断掉了，遇到这样的问题的解决方法就是<strong>寻找先序遍历。中序遍历，后序遍历的规律，找到下一个节点</strong><br>在先序遍历中，如果节点因为有右孩子而无法找到其后继节点，如果节点有左孩子，那么后继节点就是左孩子否则就一定是右孩子，。拿图 3 举 例，结点 + 的后继结点是其左孩子结点 a ，如果结点 a 不存在的话，就是结点 *</p><p>在中序遍历过程中，结点的后继是遍历其右子树时访问的第一个结点，也就是右子树中位于最左下的结点。例如图 3 中结点 * ，后继结点为结点 c ， 是其右子树中位于最左边的结点。反之，结点的前趋是左子树最后访问的那个结点。<br>后序遍历中找后继结点需要分为 3 种情况：</p><ul><li>如果该结点是二叉树的根，后继结点为空</li><li>如果该结点是父结点的右孩子（或者是左孩子，但是父结点没有右孩子），后继结点是父结点；</li><li>如果该结点是父结点的左孩子，且父结点有右子树，后继结点为父结点的右子树在后序遍历列出的第一个结点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Link, Thread</span><br><span class="line">&#125; PointerTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据为</span></span><br><span class="line">    PointerTag ltag;</span><br><span class="line">    PointerTag rtag;<span class="comment">//两个标志位</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">threadBinaryTree</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//两个指针域</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiTNode *pre = <span class="literal">NULL</span>;<span class="comment">//用pre来记录二叉树节点的前驱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiTree root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree *T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThraverse_Thr</span><span class="params">(BiTree T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree biTree;</span><br><span class="line">    createBiTree(&amp;biTree);</span><br><span class="line">    InThreading(biTree);</span><br><span class="line">    InOrderThraverse_Thr(biTree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    *T = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line">    (*T)-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"></span><br><span class="line">    (*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild = (BiTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        InThreading(T-&gt;lchild);</span><br><span class="line">        <span class="comment">//如果当前节点没有左孩子，那么就将ltag设置为1，左孩子指针指向上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (!T-&gt;lchild) &#123;</span><br><span class="line">            T-&gt;lchild = pre;</span><br><span class="line">            T-&gt;ltag = Thread;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            T-&gt;ltag=Link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pre没有右孩子，那么就将rtag设置为1，右孩子指针指向上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; !pre-&gt;rchild) &#123;<span class="comment">//说明，这里的pre保存的是当前二叉树节点的前驱，如果这个前驱，没有右孩子节点，说明T就是pre的后继</span></span><br><span class="line">            pre-&gt;rchild = T;</span><br><span class="line">            pre-&gt;rtag = Thread;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            T-&gt;rtag=Link;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = T;</span><br><span class="line">        InThreading(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThraverse_Thr</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T) &#123;</span><br><span class="line">        <span class="keyword">while</span> (T-&gt;ltag == Link) &#123;</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="keyword">while</span> (T-&gt;rtag == Thread &amp;&amp; T-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线索二叉树&quot;&gt;&lt;a href=&quot;#线索二叉树&quot; class=&quot;headerlink&quot; title=&quot;线索二叉树&quot;&gt;&lt;/a&gt;线索二叉树&lt;/h1&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>遍历二叉树</title>
    <link href="https://i-fire.top/post/traverBinaryTree.html"/>
    <id>https://i-fire.top/post/traverBinaryTree.html</id>
    <published>2021-03-19T12:45:29.000Z</published>
    <updated>2021-03-19T12:47:36.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h3 id="二叉树的先序遍历"><a href="#二叉树的先序遍历" class="headerlink" title="二叉树的先序遍历"></a>二叉树的先序遍历</h3><p>所谓二叉树的先序遍历指的是</p><ul><li>先遍历根节点</li><li>访问当前节点的左子树</li><li>如果当前节点没有左子树，那么就访问右子树</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318210610.png"></p><p>以图一为例：</p><ul><li>先访问根节点，得到节点1</li><li>访问节点1的左子树，得到节点2</li><li>访问节点2的左子树，得到节点4</li><li>访问节点4的左子树，发现没有左子树，继续访问节点4的右子树，发现没有右子树，此时返回到节点4的上一级节点2</li><li>访问节点2的右子树，得到节点5</li><li>由于节点 5 无左右子树，因此节点 5 遍历完成，并且由此以节点 2 为根节点的子树也遍历完成。现在回到节点 1 ，并开始遍历该节点的右子树，即访问节点 3</li><li>访问节点 3 左子树，找到节点 6</li><li>由于节点 6 无左右子树，因此节点 6 遍历完成，回到节点 3 并遍历其右子树，找到节点 7</li><li>节点 7 无左右子树，因此以节点 3 为根节点的子树遍历完成，同时回归节点 1。由于节点 1 的左右子树全部遍历完成，因此整个二叉树遍历完成</li></ul><blockquote><p>因此图一二叉树的先序遍历的访问顺序是1,2,4,5,3,6,7</p></blockquote><h4 id="先序遍历的递归实现"><a href="#先序遍历的递归实现" class="headerlink" title="先序遍历的递归实现"></a>先序遍历的递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//构造结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>  data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br><span class="line"><span class="comment">//初始化树的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree* T)</span></span>;</span><br><span class="line"><span class="comment">//递归先序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree* T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">BiTree Tree;</span><br><span class="line">CreateBiTree(&amp;Tree);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;先序遍历: \n&quot;</span>);</span><br><span class="line">PreOrderTraverse(Tree);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree* T)</span> </span>&#123;</span><br><span class="line">*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line">(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"></span><br><span class="line">(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTNode* T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前二叉树节点的值是：%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序遍历的非递归实现"><a href="#先序遍历的非递归实现" class="headerlink" title="先序遍历的非递归实现"></a>先序遍历的非递归实现</h4><p>先序遍历的非递归实现依靠的是栈这样的存储结构，因为使用栈我们可以模拟出递归的思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">BiTNode* arr[<span class="number">20</span>];</span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(s* <span class="built_in">stack</span>, BiTNode* node)</span></span>;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(s* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">getNode</span><span class="params">(s* <span class="built_in">stack</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BiTree* root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree* T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">BiTree root;</span><br><span class="line">createBiTree(&amp;root);</span><br><span class="line">preOrderTraverse(root);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBiTree</span><span class="params">(BiTree* T)</span> </span>&#123;</span><br><span class="line">(*T) = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line">(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(s* <span class="built_in">stack</span>, BiTNode* node)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>-&gt;arr[++<span class="built_in">stack</span>-&gt;top] = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(s* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BiTNode* <span class="title">getNode</span><span class="params">(s* <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>-&gt;arr[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">s* st = (s*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(s));</span><br><span class="line">st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">BiTNode* p;<span class="comment">//定义一个临时变量</span></span><br><span class="line">push(st, root);<span class="comment">//根节点进栈</span></span><br><span class="line"><span class="keyword">while</span> (st-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">p = getNode(st);<span class="comment">//取栈顶元素</span></span><br><span class="line">pop(st);</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前节点是%d\n&quot;</span>, p-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild) &#123;<span class="comment">//如果当前的p节点还有右孩子，那么就让右孩子进栈</span></span><br><span class="line">push(st, p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p>所谓二叉树的先序遍历指的是</p><ul><li>访问当前节点的左子树</li><li>访问当前的节点</li><li>访问当前节点的右子树</li></ul><p>以图 1 为例，采用中序遍历的思想遍历该二叉树的过程为：</p><ul><li>访问该二叉树的根节点，找到 1</li><li>遍历节点 1 的左子树，找到节点 2；</li><li>遍历节点 2 的左子树，找到节点 4；</li><li>由于节点 4 无左孩子，因此找到节点 4，并遍历节点 4 的右子树；</li><li>由于节点 4 无右子树，因此节点 2 的左子树遍历完成，访问节点 2；</li><li>遍历节点 2 的右子树，找到节点 5；</li><li>由于节点 5 无左子树，因此访问节点 5 ，又因为节点 5 没有右子树，因此节点 1 的左子树遍历完成，访问节点 1 ，并遍历节点 1 的右子树，找到节点 3</li><li>遍历节点 3 的左子树，找到节点 6</li><li>由于节点 6 无左子树，因此访问节点 6，又因为该节点无右子树，因此节点 3 的左子树遍历完成，开始访问节点 3 ，并遍历节点 3 的右子树，找到节点 7</li><li>由于节点 7 无左子树，因此访问节点 7，又因为该节点无右子树，因此节点 1 的右子树遍历完成，即整棵树遍历完成；</li></ul><blockquote><p>因此图一二叉树的中序遍历的访问顺序是4 2 5 1 6 3 7</p></blockquote><h4 id="中序遍历递归实现"><a href="#中序遍历递归实现" class="headerlink" title="中序遍历递归实现"></a>中序遍历递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其余代码请参照先序遍历递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse1</span><span class="params">(BiTNode* T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T) &#123;</span><br><span class="line">PreOrderTraverse(T-&gt;lchild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前二叉树节点的值是：%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">InOrderTraverse1(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历非递归实现"><a href="#中序遍历非递归实现" class="headerlink" title="中序遍历非递归实现"></a>中序遍历非递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse1</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">s* st = (s*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(s));</span><br><span class="line">st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">BiTNode* p;<span class="comment">//定义一个临时变量</span></span><br><span class="line">push(st, root);<span class="comment">//根节点进栈</span></span><br><span class="line"><span class="keyword">while</span> (st-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="keyword">while</span> ((p = getNode(st)) &amp;&amp; p) &#123;</span><br><span class="line">push(st, p-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line">pop(st);<span class="comment">//此时的栈顶元素一定是NULL，因此需要进行一次pop操作将NULL弹出</span></span><br><span class="line"><span class="keyword">if</span> (st-&gt;top != <span class="number">-1</span>) &#123;</span><br><span class="line">p = getNode(st);</span><br><span class="line">pop(st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前节点是%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">push(st, p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p>二叉树的后续遍历的思路：</p><ul><li>从根节点出发，依次遍历各节点的左右子树</li><li>直到当前节点左右子树遍历完成后，才访问该节点元素。</li></ul><p>以图一为例</p><ul><li>从根节点 1 开始，遍历该节点的左子树（以节点 2 为根节点）；</li><li>遍历节点 2 的左子树（以节点 4 为根节点）；</li><li>由于节点 4 既没有左子树，也没有右子树，此时访问该节点中的元素 4，并回退到节点 2 ，遍历节点 2 的右子树（以 5 为根节点）；</li><li>由于节点 5 无左右子树，因此可以访问节点 5 ，并且此时节点 2 的左右子树也遍历完成，因此也可以访问节点 2；</li><li>此时回退到节点 1 ，开始遍历节点 1 的右子树（以节点 3 为根节点）；</li><li>遍历节点 3 的左子树（以节点 6 为根节点）；</li><li>由于节点 6 无左右子树，因此访问节点 6，并回退到节点 3，开始遍历节点 3 的右子树（以节点 7 为根节点）；</li><li>由于节点 7 无左右子树，因此访问节点 7，并且节点 3 的左右子树也遍历完成，可以访问节点 3；节点 1 的左右子树也遍历完成，可以访问节点 1；</li></ul><blockquote><p>二叉树的后续遍历顺序是 4 5 2 6 7 3 1</p></blockquote><h4 id="后序遍历的递归实现"><a href="#后序遍历的递归实现" class="headerlink" title="后序遍历的递归实现"></a>后序遍历的递归实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前二叉树节点的值是：%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，遍历二叉树</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树的存储结构</title>
    <link href="https://i-fire.top/post/treeModel.html"/>
    <id>https://i-fire.top/post/treeModel.html</id>
    <published>2021-03-18T08:04:49.000Z</published>
    <updated>2021-03-18T08:07:07.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>二叉树的顺序存储结构，指的是使用数组存储二叉树，但是需要注意的是顺序存储只适合用于存储完全二叉树。<br><strong>因此：如果我们想存储普通的二叉树，需要提前将普通二叉树转换为完全二叉树</strong></p><blockquote><p>满二叉树也可以使用顺序存储。要知道，满二叉树也是完全二叉树，因为它满足完全二叉树的所有特征。</p></blockquote><p>普通二叉树转换成完全二叉树的方法很简单，只需要给二叉树额外的添加一些节点，经其拼凑成完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081507.png"></p><p>完全二叉树的顺序存储，仅需要从根节点开始，按照层次依次将树中节点存储到数组中<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081908.png"></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081958.png"></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318082023.png"></p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>从二叉树的顺序存储中可以看出，二叉树实际上不适合用数组进行存储，因为<strong>并不是每个二叉树都是完全二叉树</strong>，普通二叉树使用顺序表多多少少会存在浪费空间的现象，因此引入了二叉树的链式存储结构。<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083131.png"></p><p>如图所示，这是一个普通的二叉树，若将其采用链式存储结构，则需要从树的根节点开始，将各个节点及其左右孩子使用链表存储即可<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083321.png"></p><p>由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：</p><ul><li>指向左孩子节点的指针（Lchild）；</li><li>节点存储的数据（data）；</li><li>指向右孩子节点的指针（Rchild）；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083845.png"></p>]]></content>
    
    
    <summary type="html">数据结构，树，树的存储结构</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://i-fire.top/post/binaryTree.html"/>
    <id>https://i-fire.top/post/binaryTree.html</id>
    <published>2021-03-13T06:53:29.000Z</published>
    <updated>2021-03-13T06:56:23.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉树：每个节点至多只能有两个子树（即不存在度大于2的节点），其子树（也称为二叉树）有左右之分且次序不能任意颠倒的树称为二叉树</p><p><strong>二叉树的五种形态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313140247.png"></p><ul><li>（a）：空二叉树</li><li>（b）：只有根节点的二叉树</li><li>（c）：右子树为空的二叉树</li><li>（d）：左右子树均为非空的二叉树</li><li>（e）：左子树为空的二叉树</li></ul><h3 id="完全二叉树-满二叉树"><a href="#完全二叉树-满二叉树" class="headerlink" title="完全二叉树/满二叉树"></a>完全二叉树/满二叉树</h3><ul><li><p>满二叉树定义：如果二叉树中除了叶子节点之外的所有节点的度都为2，则此二叉树称为满二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313144534.png"></p></li><li><p>完全二叉树定义：如果二叉树去掉最后一层节点为满二叉树且最后一层的节点从左到右依次分布，则此二叉树称为完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313144737.png"></p></li></ul><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>在二叉树的第i（i&gt;=1）层上，至多有2<sup>i-1</sup>个节点</li><li>深度为k（k&gt;=1）的二叉树至多有2<sup>k</sup>-1个节点</li><li>对任意一颗二叉树T，如果其叶子节点树为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1</li><li>具有n个节点的<strong>完全二叉树</strong>的深度为[log<sub>2</sub><sup>n</sup>]+1，[x]表示不大于x的最大整数</li><li>对于一颗有n个节点的<strong>完全二叉树</strong>（其深度为[log<sub>2</sub><sup>n</sup>]+1）的节点按照层序进行遍历（从第1层到第[log<sub>2</sub><sup>n</sup>]+1层，每层从左到右）对任一节点有<ul><li>如果i=1，则节点是二叉树的根，无双亲</li><li>如果i&gt;1则其双亲节点是[i/2]</li><li>如果2i&gt;n，则节点i没有左孩子（节点i为叶子节点），否则其左孩子是节点2i</li><li>如果2i+1&gt;n，则节点i没有右孩子，否则其右孩子是节点2n+1</li></ul></li></ul>]]></content>
    
    
    <summary type="html">树，fire&#39;s blog,数据结构与算法</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://i-fire.top/post/tree.html"/>
    <id>https://i-fire.top/post/tree.html</id>
    <published>2021-03-13T06:53:29.000Z</published>
    <updated>2021-03-13T06:55:53.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树是n（n&gt;=0）个节点构成的集合</p><ul><li>当n=0时，称为空树</li><li>在一颗树中<ul><li>有且仅有一个特定的节点称为<strong>根</strong></li><li>当n&gt;1时，其余节点可以分为m（m&gt;0）个互不相交的有限集T<sub>1</sub>,T<sub>2</sub>…..T<sub>m</sub>，其中每一个集合又是一棵树，并且称为根的子树</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313080552.png"></p><h3 id="树的表示形式"><a href="#树的表示形式" class="headerlink" title="树的表示形式"></a>树的表示形式</h3><p>（a）嵌套集合表示树：用集合和嵌套的集合表示树，如图 6-2（a）； </p><p>（b）广义表表示树：根作为由子树森林组成的表的名字写在表的左边，如图 6-2（b）； </p><p>（c）凹入法表示树：如图 6-2（c）</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313080853.png"></p><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><ul><li>节点：树的节点包含一个数据元素以及若干指向其子树的分支</li><li>节点的度：节点拥有的子树个数</li><li>树的度：树内各节点的度的最大值</li><li>叶子节点（终端节点）：度为0的节点称为叶子节点或者终端节点，度不为0的称为非终端节点或者分支节点</li><li>节点的孩子，双亲：节点的子树称为节点的孩子，相应的该节点称为孩子的双亲</li><li>兄弟节点：同一双亲的孩子节点直接称为兄弟节点</li><li>树的深度：树中节点的最大层次称为树的深度</li><li>节点的祖先：从根到该节点所经分支上的所有的节点</li><li>节点的子孙：以该节点为根的子树中的任一节点</li><li>结点的堂兄弟：其双亲在同一层的结点互为堂兄弟。</li><li>森林：m（m≥0）棵互不相交的树的集合。</li></ul>]]></content>
    
    
    <summary type="html">树，fire&#39;s blog,数据结构与算法</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>串的模式匹配算法</title>
    <link href="https://i-fire.top/post/BfKmp.html"/>
    <id>https://i-fire.top/post/BfKmp.html</id>
    <published>2021-03-11T23:47:02.000Z</published>
    <updated>2021-03-11T23:49:37.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h1><p>串的模式匹配，简要的来说就是判断两个串之间是否有主串和子串的关系实现串的模式匹配的算法主要有以下两种：</p><ul><li>普通的模式匹配算法；</li><li>快速匹配算法</li></ul><h3 id="普通模式匹配算法（BF算法）"><a href="#普通模式匹配算法（BF算法）" class="headerlink" title="普通模式匹配算法（BF算法）"></a>普通模式匹配算法（BF算法）</h3><p>BF算法又称为暴力穷举法，他的实现过程没有任何的技巧，就是简单粗暴的拿一个串的字符和另外一个串中的字符一一比较<br>例如，使用普通模式匹配算法判断串 A（”abcac”）是否为串 B（”ababcabacabab”）子串的判断过程如下：<br>首先，将串 A 与串 B 的首字符对齐，然后逐个判断相对的字符是否相等，如<a href="http://data.biancheng.net/view/200.html">图</a> 1 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081817.png"></p><p>图 1 中，由于串 A 与串 B 的第 3 个字符匹配失败，因此需要将串 A 后移一个字符的位置，继续同串 B 匹配，如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081848.png"></p><p>图 2 中可以看到，两串匹配失败，串 A 继续向后移动一个字符的位置，如图 3 所示<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081945.png"></p><p>图 3 中，两串的模式匹配失败，串 A 继续移动，一直移动至图 4 的位置才匹配成功：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228082012.png"></p><p>由此，串 A 与串 B 以供经历了 6 次匹配的过程才成功，通过整个模式匹配的过程，证明了串 A 是串 B 的子串（串 B 是串 A 的主串）。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>* ch;<span class="comment">//存放串</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(str* p, str* c)</span></span>;<span class="comment">//获取一个串在另外一个串中的位置，匹配成功返回所在位置，匹配失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">str* strOne = (<span class="built_in">malloc</span>)(<span class="keyword">sizeof</span>(str));</span><br><span class="line">strOne-&gt;length = <span class="number">7</span>;</span><br><span class="line">strOne-&gt;ch = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str* strTwo = (<span class="built_in">malloc</span>)(<span class="keyword">sizeof</span>(str));</span><br><span class="line">strTwo-&gt;length = <span class="number">3</span>;</span><br><span class="line">strTwo-&gt;ch = <span class="string">&quot;efg&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bf(strOne, strTwo));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(str* p, str* c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; p-&gt;length &amp;&amp; j &lt; c-&gt;length) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;ch)[i] == (c-&gt;ch)[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == c-&gt;length) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：代码中j的作用：j不仅记录着循环体重串c中数组的下标，同时j还有记录串p和串c同时循环了多少次的问题，i-j即表示让i回到原来的位置上，i-j+1则表示让i移动到串p数组中当前元素的下一个元素的位置上</strong></p><h3 id="快速匹配算法（KMP算法）"><a href="#快速匹配算法（KMP算法）" class="headerlink" title="快速匹配算法（KMP算法）"></a>快速匹配算法（KMP算法）</h3><p><strong>暂时还未想好怎么写文章</strong></p>]]></content>
    
    
    <summary type="html">串的模式匹配算法，kmp，bf</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="串" scheme="https://i-fire.top/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>串</title>
    <link href="https://i-fire.top/post/str.html"/>
    <id>https://i-fire.top/post/str.html</id>
    <published>2021-02-27T09:58:58.000Z</published>
    <updated>2021-02-27T10:00:31.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>串（字符串）是由零个或者多个字符组成的有限序列，一般记为S=’a<sub>1</sub>a<sub>2</sub>…..a<sub>n</sub>‘<br>从严格意义上来说，串的结构也是一种线性存储结构，因为字符串中的字符之间也是具有“一对一”的逻辑关系，只不过与之前的线性结构不同的是，串只能存储字符型数据</p><h3 id="串的基本术语"><a href="#串的基本术语" class="headerlink" title="串的基本术语"></a>串的基本术语</h3><ul><li>空串：存储0个字符的串，例如S=””</li><li>空格串：只包含空格字符的串，例如：“        ”</li><li>子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = “shujujiegou”，b = “shuju”，由于 a 中也包含 “shuju”，因此串 a 和串 b 是主串和子串的关系；</li></ul><p><strong>注意：需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 “shujiejugou” 和 “shuju” 就不是主串和子串的关系。</strong></p><ul><li>另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。<strong>例如，串 a = “shujujiegou”，串 b = “jiegou”，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 ‘j’ 的位置是 6</strong></li></ul><h3 id="串的定长顺序存储结构"><a href="#串的定长顺序存储结构" class="headerlink" title="串的定长顺序存储结构"></a>串的定长顺序存储结构</h3><p>串的定长顺序存储结构，可以简单地理解为采用 “固定长度的顺序存储结构” 来存储字符串，因此限定了其底层实现只能使用静态数组。<br>使用定长顺序存储结构存储字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。<br>例如，采用定长顺序存储结构存储 “data.biancheng.net”，通过目测得知此字符串长度为 18（不包含结束符 ‘\0’），因此我们申请的数组空间长度至少为 18，用 C 语言表示为：</p><blockquote><p>char str[18] = “data.biancheng.net”;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">&quot;data.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串的堆分配存储结构"><a href="#串的堆分配存储结构" class="headerlink" title="串的堆分配存储结构"></a>串的堆分配存储结构</h3><p><a href="http://data.biancheng.net/view/175.html">串</a>的堆分配存储，其具体实现方式是采用动态<a href="http://data.biancheng.net/view/181.html">数组</a>存储字符串。<br>通常，编程语言会将程序占有的内存空间分成多个不同的区域，程序包含的数据会被分门别类并存储到对应的区域。拿 C 语言来说，程序会将内存分为 4 个区域，分别为堆区、<a href="http://data.biancheng.net/view/169.html">栈</a>区、数据区和代码区，其中的堆区是本节所关注的。<br>与其他区域不同，堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。<br>C 语言中使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。例如：</p><blockquote><p>char * a = (char*)malloc(5*sizeof(char));</p></blockquote><p>此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。<br>动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）：</p><blockquote><p>a = (char*)realloc(a, 10*sizeof(char));</p></blockquote><p>通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。<br>一个完整的示例，以便对串的堆分配存储有更清楚地认识。该程序可实现将两个串（”data.bian” 和 “cheng.net”）合并为一个串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * a1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * a2 = <span class="literal">NULL</span>;</span><br><span class="line">    a1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(a1, <span class="string">&quot;data.bian&quot;</span>);<span class="comment">//将字符串&quot;data.bian&quot;复制给a1</span></span><br><span class="line">    a2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(a2, <span class="string">&quot;cheng.net&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> lengthA1 = <span class="built_in">strlen</span>(a1);<span class="comment">//a1串的长度</span></span><br><span class="line">    <span class="keyword">int</span> lengthA2 = <span class="built_in">strlen</span>(a2);<span class="comment">//a2串的长度</span></span><br><span class="line">    <span class="comment">//尝试将合并的串存储在 a1 中，如果 a1 空间不够，则用realloc动态申请</span></span><br><span class="line">    <span class="keyword">if</span> (lengthA1 &lt; lengthA1 + lengthA2) &#123;</span><br><span class="line">        a1 = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(a1, (lengthA1 + lengthA2+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个串到 a1 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lengthA1; i &lt; lengthA1 + lengthA2; i++) &#123;</span><br><span class="line">        a1[i] = a2[i - lengthA1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//串的末尾要添加 \0，避免出错</span></span><br><span class="line">    a1[lengthA1 + lengthA2] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a1);</span><br><span class="line">    <span class="comment">//用完动态数组要立即释放</span></span><br><span class="line">    <span class="built_in">free</span>(a1);</span><br><span class="line">    <span class="built_in">free</span>(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，程序中给 a1 和 a2 赋值时，使用了 strcpy 复制函数。这里不能直接用 a1 =”data.biancheng”，程序编译会出错，报错信息为 “没有 malloc 的空间不能 free”。因为 strcpy 函数是将字符串复制到申请的存储空间中，而直接赋值是字符串存储在别的内存空间（本身是一个常量，放在数据区）中，更改了指针 a1 和 a2 的指向，也就是说，之前动态申请的存储空间虽然申请了，结果还没用呢就丢了。</p></blockquote><h3 id="串的块链存储"><a href="#串的块链存储" class="headerlink" title="串的块链存储"></a>串的块链存储</h3><p><a href="http://data.biancheng.net/view/175.html">串</a>的块链存储，指的是使用<a href="http://data.biancheng.net/view/160.html">链表</a>结构存储字符串。<br>本节实现串的块链存储使用的是无头节点的单链表。当然根据实际需要，你也可以自行决定所用链表的结构（<a href="http://data.biancheng.net/view/166.html">双向链表</a>还是单链表，有无头节点）。<br>我们知道，单链表中的 “单” 强调的仅仅是链表各个节点只能有一个指针，并没有限制数据域中存储数据的具体个数。因此在设计链表节点的结构时，可以令各节点存储多个数据。<br>例如，<a href="http://data.biancheng.net/view/200.html">图</a> 1 所示是用链表存储字符串 <code>shujujiegou</code>，该链表各个节点中可存储 1 个字符：</p><p><img src="C:\Users\15061\AppData\Roaming\Typora\typora-user-images\image-20210227084947458.png" alt="image-20210227084947458"></p><p>同样，图 2 设置的链表各节点可存储 4 个字符：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210227085012.png"></p><p>从图 2 可以看到，使用链表存储字符串，其最后一个节点的数据域不一定会被字符串全部占满，对于这种情况，通常会用 ‘#’ 或其他特殊字符（能与字符串区分开就行）将最后一个节点填满。<br>用块链结构存储字符串时，怎样确定链表中节点存储数据的个数呢？？？链表各节点存储数据个数的多少可参考以下几个因素：</p><ul><li><p>串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑；</p></li><li><p>程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> linkNum 3<span class="comment">//全局设置链表中节点存储数据的个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[linkNum]; <span class="comment">//数据域可存放 linkNum 个数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> * <span class="title">next</span>;</span> <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;link; <span class="comment">// nk为节点名，每个节点都是一个 link 结构体</span></span><br><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">(link * head, <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLink</span><span class="params">(link * head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link * head = <span class="literal">NULL</span>;</span><br><span class="line">    head = initLink(head, <span class="string">&quot;data.biancheng.net&quot;</span>);</span><br><span class="line">    displayLink(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化链表，其中head为头指针，str为存储的字符串</span></span><br><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">(link * head, <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="comment">//根据字符串的长度，计算出链表中使用节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> num = length/linkNum;</span><br><span class="line">    <span class="keyword">if</span> (length%linkNum) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建并初始化首元节点</span></span><br><span class="line">    head = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    link *temp = head;</span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j&lt;linkNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i*linkNum + j &lt; length) &#123;</span><br><span class="line">                temp-&gt;a[j] = str[i*linkNum + j];</span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp-&gt;a[j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*linkNum + j &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            link * newlink = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">            newlink-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            temp-&gt;next = newlink;</span><br><span class="line">            temp = newlink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLink</span><span class="params">(link * head)</span> </span>&#123;</span><br><span class="line">    link * temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkNum; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, temp-&gt;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，串</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="串" scheme="https://i-fire.top/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://i-fire.top/post/queue.html"/>
    <id>https://i-fire.top/post/queue.html</id>
    <published>2021-02-26T06:13:59.000Z</published>
    <updated>2021-02-26T06:15:27.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列：和栈一样，也是一种对数据的<strong>存取</strong>有严格要求的线性存储结构<br>与栈不同的是，队列的两端都要开口，同时要求数据只能从一端进，从另一端出<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226084414.png"></p><blockquote><p>通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。不仅如此，队列中数据的进出要遵循 “先进先出” 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p></blockquote><blockquote><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><h3 id="队列的顺序表示"><a href="#队列的顺序表示" class="headerlink" title="队列的顺序表示"></a>队列的顺序表示</h3><p>顺序队列的实现使用的是<strong>数组</strong>，为了满足顺序队列中数据从队尾进入，从队头出且先进先出的要求，因此我们还需要两个指针（top和rear）分别指向顺序队列中的队头元素和队尾元素<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226084819.png"></p><p>因为顺序队列初始状态没有存储任何的元素，因此top指针和rear指针重合<br>在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。<br>例如，在图 1 基础上将 <code>&#123;1,2,3,4&#125;</code> 用顺序队列存储的实现操作如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085142.png"></p><p>在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085225.png"></p><p>但是如果仔细观察这样的操作就会发现这样的操作是有问题的<br>先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出（假上溢）错误；</li></ul><p>针对这样的假上溢，我们可以将原来的顺序表制作成一个环形结构（循环队列）</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085649.png"></p><p>这只是一个逻辑结构，在实际的存储中我们依然使用的是数组这样的线性结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];<span class="comment">//存放数据的数组</span></span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//队头元素下标</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//队尾元素下标</span></span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">initQueue</span><span class="params">()</span></span>;<span class="comment">//获取一个队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popQueue</span><span class="params">(<span class="built_in">queue</span>* p)</span></span>;<span class="comment">//队列出队一个元素，同时返回这个出队的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushQueue</span><span class="params">(<span class="built_in">queue</span>* p, <span class="keyword">int</span> e)</span></span>;<span class="comment">//队列入队一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>* p = initQueue();</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">popQueue(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>* temp = (<span class="built_in">queue</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">temp-&gt;top = <span class="number">0</span>;</span><br><span class="line">temp-&gt;rear = temp-&gt;top;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建队列失败===========&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popQueue</span><span class="params">(<span class="built_in">queue</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列出队失败========&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rear == p-&gt;top) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列出队失败=========&gt;队列为空\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = p-&gt;data[p-&gt;top];</span><br><span class="line">p-&gt;top = (p-&gt;top + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushQueue</span><span class="params">(<span class="built_in">queue</span>* p, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队失败===========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;rear + <span class="number">1</span>) % MAXSIZE == p-&gt;top) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队失败=================&gt;队满！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data[p-&gt;top] = e;</span><br><span class="line">p-&gt;rear = (p-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，队列</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="https://i-fire.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://i-fire.top/post/satck.html"/>
    <id>https://i-fire.top/post/satck.html</id>
    <published>2021-02-25T06:22:28.000Z</published>
    <updated>2021-02-25T06:24:45.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>和<strong>顺序表，链表</strong>一样，栈也是用来存储逻辑关系为一对一数据的线性结构存储</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225082359.png"></p><p>如图所示，栈的存储结构与之前的线性结构有所差异，因为栈对于数据的存和取的过程有特殊的要求</p><ul><li>栈只能从表的一端存取数据，另一端是封闭的</li><li>在栈中，无论是存储数据还是取数据，都必须遵循先进后厨的原则，即最先进栈的元素最后出栈</li></ul><p>因此，我们可以给栈下一个定义，即栈是一种<strong>只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构</strong><br>通常。栈的开口端被称为<strong>栈顶</strong>，相应的，封口端被称为<strong>栈底</strong>，因此，栈顶元素指的就是距离栈顶最近的元素拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225082813.png"></p><h3 id="进栈和出栈"><a href="#进栈和出栈" class="headerlink" title="进栈和出栈"></a>进栈和出栈</h3><p>基于栈的结构特点，在实际的应用中，通常只会对栈执行以下的两种操作</p><ul><li>向栈中添加元素，此过程被称为<strong>进栈</strong>（入栈或者压栈）</li><li>从栈中取出指定的元素，此过程称为<strong>出站</strong>（弹栈）</li></ul><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>基于栈结构对数据存取采用 “先进后出” 原则的特点，它可以用于实现很多功能。</p><p>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：</p><ul><li>重新搜索找到页面 A；</li><li>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。<br>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。</li></ul><p>不仅如此，栈存储结构还可以帮我们检测代码中的<a href="http://data.biancheng.net/view/87.html">括号匹配</a>问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。</p><p>同时，栈结构还可以实现数值的<a href="http://data.biancheng.net/view/86.html">进制转换</a>功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。</p><h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3><p><strong>顺序栈</strong>，即用<strong>顺序表</strong>实现栈存储结构。通过前面的学习我们知道，使用栈存储结构操作数据元素必须遵守 “先进后出” 的原则<br>当我们使用顺序表（a数组）存储{1,2,3,4}时，应该是这个样的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225085253.png"></p><p>同样，使用栈存储{1,2,3,4}时，应该是这个样的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225085443.png"></p><p>通过这两个图对比介意发现，使用顺序表模拟栈的结构很容易，只需要将数据从数组下标为0的位置依次存储即可</p><h4 id="栈的顺序结构"><a href="#栈的顺序结构" class="headerlink" title="栈的顺序结构"></a>栈的顺序结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10<span class="comment">//定义顺序栈的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span>* top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span>* base;<span class="comment">//栈底元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现顺序栈"><a href="#实现顺序栈" class="headerlink" title="实现顺序栈"></a>实现顺序栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 3<span class="comment">//定义顺序栈的最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span>* top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span>* base;<span class="comment">//栈底元素的指针</span></span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>* <span class="title">initStack</span><span class="params">()</span></span>;<span class="comment">//获取一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isStackEmpty</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//判断栈循序栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInStack</span><span class="params">(<span class="built_in">stack</span>* s, <span class="keyword">int</span> e)</span></span>;<span class="comment">//将一个元素入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//顺序栈出栈，同时返回出出栈的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//销毁顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//清空顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStackLength</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//求顺序栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>* s = initStack();</span><br><span class="line">addInStack(s, <span class="number">1</span>);</span><br><span class="line">addInStack(s, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈的长度是===========&gt;%d\n&quot;</span>,getStackLength(s));</span><br><span class="line">addInStack(s, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈是否为空===============&gt;%d\n&quot;</span>, isStackEmpty(s));</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>* <span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>* p = (<span class="built_in">stack</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取一个栈失败============&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;base = &amp;(p-&gt;data[<span class="number">0</span>]);</span><br><span class="line">p-&gt;top = &amp;(p-&gt;data[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isStackEmpty</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断顺序栈是否为空错误=============&gt;参数错误]\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInStack</span><span class="params">(<span class="built_in">stack</span>* s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈入栈失败============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == MAXSIZE) &#123;<span class="comment">//说明当前栈已经满了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈添加元素失败===============&gt;栈满了\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">*(s-&gt;top) = e;</span><br><span class="line">s-&gt;top = s-&gt;top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈失败=============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈失败============&gt;栈为空\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top = s-&gt;top - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *(s-&gt;top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁顺序栈失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空顺序栈失败=================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top = s-&gt;base;<span class="comment">//直接将栈顶指针指向栈底，这样就可以了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStackLength</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取顺序栈长度失败========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (s-&gt;top - s-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式结构（链栈）"><a href="#栈的链式结构（链栈）" class="headerlink" title="栈的链式结构（链栈）"></a>栈的链式结构（链栈）</h3><p>链栈：用链表实现栈的存储结构<br>链栈的实现思路同<strong>顺序栈</strong>类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225140305.png"></p><blockquote><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p></blockquote><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li><li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</li><li>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</li></ul><h4 id="链栈的结构"><a href="#链栈的结构" class="headerlink" title="链栈的结构"></a>链栈的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d &quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素：%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈已空\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈内没有元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，栈</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="栈" scheme="https://i-fire.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>双向链表</title>
    <link href="https://i-fire.top/post/twoWayLinkedList.html"/>
    <id>https://i-fire.top/post/twoWayLinkedList.html</id>
    <published>2021-02-23T11:04:37.000Z</published>
    <updated>2021-02-23T11:08:57.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>在之前学习的的链表中，无论是静态链表或者是动态链表，在他们的每一个节点中值包含一个指针（游标），而且指针都是同一个指向后继节点，通常称这类链表为单向链表（或单链表）。，使用这些单链表虽然可以解决逻辑关系为<strong>一对一</strong>数据的存储问题，但是在解决某些特殊问题的时候，这些链表并不是效率最优的存储结构，比如说，在某些情况下需要大量的查找某节点的前驱节点，使用单链表无疑是很繁琐的，因为单链表更适合的是<strong>从前往后找</strong>并，<strong>从后往前找</strong>并不是他的强项！<br>对于逆向查找（从后往前进行查找）相关的问题，我们可以使用<strong>双向链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双向链表，简称双链表。从名字上理解双向链表，即链表是 “双向” 的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082035.png"></p><p>所谓双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要，可以为最后一个节点再设置一个“头指针”。<br>根据上图可知，双向链表中各个节点包含以下3部分信息</p><ul><li>指针域：指向当前节点的前驱节点</li><li>数据域：存储数据元素</li><li>指针域：用于指向当前节点的直接后继节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082258.png"></p><h3 id="双向链表的代码实现"><a href="#双向链表的代码实现" class="headerlink" title="双向链表的代码实现"></a>双向链表的代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">//定义双向链表的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">pre</span>;</span><span class="comment">//当前节点的前驱节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//当前节点的后继节点指针</span></span><br><span class="line">&#125; tWLLNode;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span></span>;<span class="comment">//获取一个双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//判断双向链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的头部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在中间添加一个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//遍历双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//获取双向链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取节点的值并返回，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//销毁整个双向链表包括头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除节点,index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">tWLLNode* head = initTwoWayLinkedList();</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">19</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">1</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">2</span>);</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">190</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">3</span>);</span><br><span class="line">addEleTwoLinkedListByIndex(head, <span class="number">2</span>, <span class="number">89</span>);</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line">deleteTwoWayLinkedListByIndex(head, <span class="number">5</span>);</span><br><span class="line">outTwoWayLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表是否为空==========================&gt;%d\n&quot;</span>, isTwoWayLinkedListEmpty(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表的长度是=======================&gt;%d\n&quot;</span>, getTwoWayLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表中第199个元素是=============&gt;%d\n&quot;</span>, getEleInTwoWayLinkedListByindex(head, <span class="number">199</span>));</span><br><span class="line"><span class="comment">//destoryTwoWayLinkedList(head);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tWLLNode* head = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));<span class="comment">//构造出双向链表的头节点，有了这个头节点可以更加方便的处理双向链表</span></span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建双向链表失败=================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断双向链表是否为空失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表头插入元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表插入元素失败====================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">tWLLNode* temp = head-&gt;next;<span class="comment">//原来双向链表中的第一个节点</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;<span class="comment">//说明是第一次添加节点</span></span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历双向链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向循环链表中第%d个元素是=============&gt;%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表的尾部添加元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;<span class="comment">//第一次添加节点，直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表尾部添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i || p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败================&gt;元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;<span class="comment">//当前节点的前一个节点</span></span><br><span class="line">tWLLNode* node = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">node-&gt;pre = temp;</span><br><span class="line">node-&gt;next = p;</span><br><span class="line">p-&gt;pre = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取双向链表长度失败================参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取双向链表的值失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; i &lt; index) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取节点值失败=======================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁双向链表失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line">tWLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除首元节点失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//判断是不是只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除双向链表尾结点失败=================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点错误=====================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//说明是最后一个节点</span></span><br><span class="line">p-&gt;pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，双向链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="双向链表" scheme="https://i-fire.top/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单向循环链表</title>
    <link href="https://i-fire.top/post/circularLinkedList.html"/>
    <id>https://i-fire.top/post/circularLinkedList.html</id>
    <published>2021-02-22T07:44:15.000Z</published>
    <updated>2021-02-22T07:46:57.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>循环链表是一种头尾相接的链表，他的最后一个指针域指向头节点，形成一个环<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221083642.png"></p><p><strong>注意：</strong>虽然循环链表成环状，，但是本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等等，循环链表和普通的链表相比，唯一不同的就是循环链表首尾相连（尾结点的指针域永远指向首元节点），其他都完全一样。</p><h3 id="单向循环链表代码实现"><a href="#单向循环链表代码实现" class="headerlink" title="单向循环链表代码实现"></a>单向循环链表代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">circularLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//存放链表节点的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cLLNode</span>* <span class="title">next</span>;</span><span class="comment">//链表节点的指针域</span></span><br><span class="line">&#125;cLLNode;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span></span>;<span class="comment">//对单向循环链表进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//判断单向循环链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向循环链表尾部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向链表头部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单向循环链表第一次插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//将单向循环链表的所有的节点全部清空，只保留头指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//获取单向循环链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个元素前插入一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除单向循环链表的节点，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取元素的值，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">cLLNode* head = initCircularLinkedList();</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">119</span>);</span><br><span class="line">addEleInCircularLinkedList(head, <span class="number">12</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">13</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">14</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">15</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">7</span>, <span class="number">10000</span>);</span><br><span class="line">outCircularLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表为的长度是%d\n&quot;</span>, getCircularLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表的第8个元素是%d&quot;</span>,getEleCircularLinkedListByIndex(head,<span class="number">8</span>));</span><br><span class="line">clearCircularLinkedList(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造单向循环链表的头节点</span></span><br><span class="line">cLLNode* head = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表创建失败==================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断单向循环链表是否为空失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;<span class="comment">//说明是第一次添加元素</span></span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next) &#123;<span class="comment">//找到单向循环链表的最后一个节点</span></span><br><span class="line"></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">temp-&gt;next = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表头插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line">cLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">temp-&gt;next = p;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头插入元素失败===========&gt;空间不足\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一次插入失败========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历链表失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;<span class="comment">//单向循环链表达到表尾的条件是最后一个指针域指向首元节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空单链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环单链表插入元素失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头插入</span></span><br><span class="line">addEleInCircularLinkedListHead(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || (p-&gt;next == head-&gt;next &amp;&amp; i + <span class="number">1</span> != index)) &#123;<span class="comment">//判断是否找到当前元素的前一个元素，!p成立的的话说明当前单向循环链表是空的，如果后面 (p-&gt;next == head-&gt;next &amp;&amp; i + 1 != index)同时成立的话说明就是没有找到节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素错误=======================&gt;index对应的节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里说明已经找到当前的节点的前一个节点</span></span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败==========================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除单向循环链表的首元节点失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//单向循环链表的第二个节点</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next)<span class="comment">//查找最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* node = p-&gt;next;<span class="comment">//需要删除的首元节点</span></span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾删除失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next)<span class="comment">//找到需要删除的节点的的前一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">temp = p-&gt;next;<span class="comment">//因为不允许使用p-&gt;next-&gt;next，所以多增加一个temp变量，效果和p-&gt;next-&gt;next一样，方便找到最后一个节点的前一个节点，这个temp变量就是最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点失败==========================&gt;参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//说明是头删除</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//只有一个节点的情况</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//temp表示的就是需要删除的节点</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> == index &amp;&amp; head-&gt;next == temp-&gt;next) &#123;<span class="comment">//说明是尾删除</span></span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取元素失败===========&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != index+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构中的单向循环链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://i-fire.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>今日份开心</title>
    <link href="https://i-fire.top/post/todayHappiness.html"/>
    <id>https://i-fire.top/post/todayHappiness.html</id>
    <published>2021-02-21T11:39:53.000Z</published>
    <updated>2021-02-21T11:46:11.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天的快乐"><a href="#今天的快乐" class="headerlink" title="今天的快乐"></a>今天的快乐</h1><p>今天小学生开学了，我去了以前上小学的地方，门口的小店竟然有冷饮卖！开森！！</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221193807.jpg"></p>]]></content>
    
    
    <summary type="html">开森</summary>
    
    
    
    <category term="心情随笔" scheme="https://i-fire.top/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>静态链表</title>
    <link href="https://i-fire.top/post/staticLinkedList.html"/>
    <id>https://i-fire.top/post/staticLinkedList.html</id>
    <published>2021-02-21T11:26:43.000Z</published>
    <updated>2021-02-21T11:28:54.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h4 id="顺序表和链表的优缺点"><a href="#顺序表和链表的优缺点" class="headerlink" title="顺序表和链表的优缺点"></a>顺序表和链表的优缺点</h4><p>从之前写的动态数组（线性表的顺序存储方式）和单链表（线性表的链式存储方式）代码来说，二者都有一些优缺点，对于动态数组，<br>查询和写入（非存储）数据很快，但是当存储数据时，需要不停地移动元素，如果碰上动态数组满了的情况，那么还需要对动态数组进行扩容，对于存储来说，效率很低。对于链表来说，每次查询或者写入一个元素的时候，需要从头遍历整个链表来找到需要写入数据的节点，效率也不是很高，对于插入数据来说，只要找到当前节点的前驱，然后修改前驱节点的指针的指向即可，相比动态数组插入元素而言效率要高。有没有一种数据结构可以克服这些缺点同时继承他们的优点？？那就是<strong>静态链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。<br>使用静态链表存储数据，数据全部在数组中（类似动态数组），但是存储的位置是随机的，数据之间的链式关系（一个接一个）通过一个整型变量（称之为<strong>游标，类似单链表中每个节点的指针</strong>）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用静态链表存储数组{1,2,3}<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092258.png"></p><p>接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092407.png"></p><p>通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。<br>图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。<br>类似图 2 这样，通过 “数组+游标” 的方式存储具有线性关系数据的存储结构就是静态链表。</p><h3 id="静态链表中的节点"><a href="#静态链表中的节点" class="headerlink" title="静态链表中的节点"></a>静态链表中的节点</h3><p>静态链表中的节点也包含两个部分，但是和单链表不同的就是单链表节点中的指针域变成了静态链表中的<strong>游标</strong>，游标不是一个指针，它记录的是当前节点的下一个节点在数组中的位置（也就是数组元素的下标）</p><ul><li>数据域：存储数据元素</li><li>游标：其实就是数组下标，表示直接后继元素所在数组中的位置；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备用链表"><a href="#备用链表" class="headerlink" title="备用链表"></a>备用链表</h3><p>可以看到，图2中的数组不是很完整：数据中有6个位置，但是实际上值存储了3个元素，空出来了3个位置，这三个位置我们也是可以利用的。在静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称之为备用链表。<br>备用链表的作用是回收数组中未使用或者之前使用但是目前没有使用的存储空间，以待后期使用，也就是说，静态链表使用数组申请的物理空间，存在两个链表，一个连接着数据，另外一条连接着数组中还未使用过的空间</p><blockquote><p>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p></blockquote><p>在静态链表中使用备用链表的好处就是可以清楚地知道数组中是否有空闲位置，一遍数据链表添加数据的时候使用。如果静态链表中数组下标为0的位置上存有数据，则证明数组满了<br>例如，使用静态链表存储 <code>&#123;1,2,3&#125;</code>，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220093947.png"></p><h3 id="静态链表的实现"><a href="#静态链表的实现" class="headerlink" title="静态链表的实现"></a>静态链表的实现</h3><p>假设静态链表（长度为6）存储{1,2,3}，需要经过如下几个阶段<br>当链表没有进行初始化的时候，数组中的所有的位置都处于空闲转态，因此都应该被连接都备用链表上<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100716.png"></p><blockquote><p>备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表</p></blockquote><p>因此，在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100919.png"></p><p>在图 5 的基础上，添加元素 2 的过程如图 6 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101301.png"></p><p>在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101448.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typename int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  next;</span><br><span class="line">    <span class="keyword">typename</span> context;</span><br><span class="line">&#125;Node,List[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    InitStatic(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> h,i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>].next = h;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f);</span><br><span class="line">        <span class="built_in">list</span>[i].context = f;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>[h<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>[MAX - <span class="number">1</span>].next = <span class="number">1</span>;<span class="comment">//为已用链表的头结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    <span class="comment">/*Insert(list,1,5);</span></span><br><span class="line"><span class="comment">    printf(&quot;长度为：%d\n&quot;,get_Length(list));*/</span></span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        l[i].context = <span class="number">0</span>;</span><br><span class="line">        l[i].next = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l[MAX - <span class="number">1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLode</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">list</span>[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span>(m) &#123;</span><br><span class="line">        <span class="built_in">list</span>[<span class="number">0</span>].next = <span class="built_in">list</span>[m].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得有效长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>,i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = getLode(l),j = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; get_Length(l) + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = m;</span><br><span class="line">        l[m].next = <span class="number">1</span>;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;j &lt; i - <span class="number">1</span>;j++)  k = l[k].next;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">        l[m].next = l[k].next;</span><br><span class="line">        l[k].next = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>,m = <span class="number">1</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        f = l[MAX - <span class="number">1</span>].next;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = l[f].next;</span><br><span class="line">        l[f].next = l[<span class="number">0</span>].next;</span><br><span class="line">        l[<span class="number">0</span>].next = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;j &lt; k - <span class="number">1</span>;j++) m = l[m].next;</span><br><span class="line">    k = l[m].next;</span><br><span class="line">    l[m].next = l[k].next;</span><br><span class="line">    l[k].next = l[<span class="number">0</span>].next;</span><br><span class="line">    l[<span class="number">0</span>].next = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据的展示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>[i].next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，静态链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="静态链表" scheme="https://i-fire.top/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（）二</title>
    <link href="https://i-fire.top/post/linearStructureTwo.html"/>
    <id>https://i-fire.top/post/linearStructureTwo.html</id>
    <published>2021-02-19T09:28:03.000Z</published>
    <updated>2021-02-19T09:29:06.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的缺点<br>借助指针等手段来表示数据元素 a<sub>i</sub> 和直接后继元素 a<sub>i+1</sub> 之间的关系，a<sub>i</sub> 不仅存储本身的信息，还存储指向后继的指针。<br>数据元素（数据域）和指向后继的指针（指针域）合起来称为一个结点，n 个结点链接成一个链表即为线性表的链式存储结构。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>数据域：存储真实的数据元素</li><li>指针域：下一个节点的地址（指针）</li></ul><pre class="mermaid">graph TDA[节点] --> B[数据域]A[节点] --> C[指针域]</pre><h3 id="首元节点"><a href="#首元节点" class="headerlink" title="首元节点"></a>首元节点</h3><p>链表中第一个存放数据的元素所在的结点，它是头结点后边的第一个结点。</p><h3 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h3><p>一般把<strong>链表</strong>中的<strong>第一个结</strong>点称为 <strong>头指针</strong>，其<strong>存储</strong>链表的<strong>第一个数据元素</strong>，在有头节点的情况下头指针指向的应该是指向的是头节点，无头节点的情况下头指针指向的是首元节点</p><h3 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h3><p>为了能更加方便地对链表进行操作，会在<strong>单链表的第一个结点（即头指针）前</strong>附<strong>设一个结点</strong>，称为 <strong>头结点</strong>，头节点中可以存储一些附加数据，例如：当前线性表的长度等等,在处理某些问题时，给链表添加头结点会使问题变得简单。</p><pre class="mermaid">graph LRO[头指针]-->A[头节点]A[头节点]-->B[线性表的首元节点]A[头节点]-->C[线性表的长度]A[头节点]-->D[线性表的尾指针]A[头节点]-->M[还可以再加....]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><pre class="mermaid">graph LRO[头指针]-->B[线性表的首元节点]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><p><strong>头结点和头指针的区别</strong>：头指针是一个指针，头指针指向链表的头结点或者首元结点；头结点是一个实际存在的结点，它包含有数据域和指针域。两者在程序中的直接体现就是：头指针只声明而没有分配存储空间，头结点进行了声明并分配了一个结点的实际物理内存。单链表中可以没有头结点，但是不能没有头指针！</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>在单链表中，对于每个结点来说，除了存储本身的信息外，还需要存放一个指向其后继的指针。逻辑位置相<br>邻但物理位置不相邻的数据元素用单链表链接<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219085612.png"></p><ul><li>对于存取操作：而对于单链表结构，假设需要获取第 i 个元素，则必须从第一个结点开始依次进行遍历，直到达到第 i 个结点。因此，对于单链表结构而言，其数据元素读取的<strong>时间复杂度</strong>为<strong>O<sub>(n)</sub></strong></li><li>对于<strong>插入和删除</strong>操作：而对单链表结构来说，对其任意一个位置进行增删操作，其<strong>时间复杂度</strong>为 O<sub>(n)</sub>，<strong>因为</strong>需要先进行<strong>遍历找到目标元素</strong>，对头指针的增删操作其<strong>时间复杂度</strong>为O<sub>(1)</sub></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义单链表节点的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//节点中的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span>* <span class="title">next</span>;</span><span class="comment">//节点中的指针域</span></span><br><span class="line">&#125; sLLNode;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span></span>;<span class="comment">//初始化单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单链表头插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//遍历输出单链表中所有的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span></span>;<span class="comment">//销毁单链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在单链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//获取单链表中第index个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个位置前添加一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//删除第index位置上的元素，同时将它返回出去，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//根据数据查找对应的index，没有就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">sLLNode* singleLinkedList = initSingleLinkedList();</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">1</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">11</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">122</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">1</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">2</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">20</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1000所在的第一个节点的index是%d\n&quot;</span>,findEleByIndex(singleLinkedList,<span class="number">1000</span>));</span><br><span class="line">deleteSingleLinkedListByIndex(singleLinkedList, <span class="number">2</span>);</span><br><span class="line">outSingleLinkedList(singleLinkedList);</span><br><span class="line">destorySingleLinkedList(&amp;singleLinkedList);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的长度是%d&quot;</span>, getSingleLinkedListLength(singleLinkedList));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造出头指针</span></span><br><span class="line">sLLNode* head = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化单链表失败，失败原因===================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表头插入失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的头插入失败，失败原因==================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//用临时变量保存原来的头节点后面一个节点的地址</span></span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历单链表失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是====================&gt;%d\n&quot;</span>, i, temp-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !(*head)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁单链表失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = *head;</span><br><span class="line">sLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = temp;</span><br><span class="line">&#125;</span><br><span class="line">*head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表长度失败====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (temp)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败============================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next) &#123;<span class="comment">//当当前节点的下一个节点为空时，说明已经抵达单链表的最后一个节点！</span></span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* node = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败===================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//一定一定要将最后一个节点的next指针置为NULL！！！</span></span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表中数组失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; temp)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line"><span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表指定位置添加元素失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头添加,需要将指针p指向头指针并非是头节点，这样才能找到头添加时需要的前驱</span></span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; p) &#123;<span class="comment">//需要找到index位置的节点的前驱所以是p-&gt;next</span></span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">sLLNode* temp = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">sLLNode* currentNode = p-&gt;next;<span class="comment">//currentNode中保存的才是对应单链表中第index个节点</span></span><br><span class="line">temp-&gt;next = currentNode;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;空间不足！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;index位置的节点不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除单链表元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span> &amp;&amp; head-&gt;next) &#123;<span class="comment">//判断是不是头删除</span></span><br><span class="line">temp = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; temp) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">sLLNode* currentNode = temp-&gt;next;</span><br><span class="line">temp-&gt;next = currentNode-&gt;next;</span><br><span class="line">data = currentNode-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(currentNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;index对应的元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据值查找index失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data == e) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，单链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（一）</title>
    <link href="https://i-fire.top/post/linearStructureOne.html"/>
    <id>https://i-fire.top/post/linearStructureOne.html</id>
    <published>2021-02-19T09:23:57.000Z</published>
    <updated>2021-02-19T09:27:00.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性结构（一）"><a href="#线性结构（一）" class="headerlink" title="线性结构（一）"></a>线性结构（一）</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>含有n个相同元素的数据元素的有限序列称为线性表<br>一般可以表示为：L(a<sub>1</sub>,a<sub>2</sub>,…….,a<sub>n-1</sub>,a<sub>n</sub>)<strong>注意：</strong>a<sub>i-1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>n</sub> 的直接后继元素。线性表中数据元素的个数 n（n＞0）为线性表的长度。当 n＝0 时称线性表为空表。</p><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><pre class="mermaid">graph TDA[线性表] --> B[顺序存储结构]A[线性表] --> C[链式存储结构]B[顺序存储结构] --> D[动态数组]C[链式存储结构] --> E[单链表]C[链式存储结构] --> F[静态链表]C[链式存储结构] --> H[循环链表]C[链式存储结构] --> I[双向链表]</pre><h3 id="顺序存储结构-动态数组"><a href="#顺序存储结构-动态数组" class="headerlink" title="顺序存储结构(动态数组)"></a>顺序存储结构(动态数组)</h3><p>（又称顺序表）是一种随机存取的结构，逻辑关系上相邻的元素物理位置上也相邻。数组是表<br>示顺序存储结构最简单的一个方式。如图 2-1 所示，只要确定了存储线性表的起始位置，线性表中任一数据元素<br>都可随机存取。<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219082748.png"></p><p><strong>顺序存储结构的特点</strong></p><p>优点：</p><p>①它是一个记录型的结构。数据元素的存储位置可用数组的下标值（即相对于线性表的起始位置的值）来表</p><p>示；</p><p>②在顺序存储结构中，线性表的某些操作容易实现，如求表长的操作；</p><p>缺点：</p><p>①在做插入或删除操作时，需移动大量元素；</p><p>②在给长度变化较大的线性表预先分配空间时，必须按最大空间分配，易造成了空间的浪费；</p><p>③表的容量难以扩充</p>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器时区问题</title>
    <link href="https://i-fire.top/post/chrom.html"/>
    <id>https://i-fire.top/post/chrom.html</id>
    <published>2021-02-01T01:47:17.000Z</published>
    <updated>2021-02-01T01:56:05.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决谷歌浏览器时间不同步问题"><a href="#解决谷歌浏览器时间不同步问题" class="headerlink" title="解决谷歌浏览器时间不同步问题"></a>解决谷歌浏览器时间不同步问题</h1><p>昨天站长在谷歌浏览器测试项目的时候奇怪的发现，前端js同一个时间戳解析出来的时间与我的本地时区相差16个小时（之前在项目中就有疑惑，后台发现用户总是喜欢在凌晨注册，没有引起好奇），我是在东八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>+08:00），但是时间戳格式化出来的却是西八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>-08:00），我一直以为是js没有设置时区问题（一般来说都会按照本地时区对时间戳进行格式化，基本不会让开发者自己设置），于是我各种百度，找到的解决办法也是五花八门（到此为止我还没有意识到是谷歌浏览器自己出问题，并非是我的电脑问题），然后我才想起来同一个时间戳放到不同的浏览器上去解析一下，验证是不是我的时区问题。嘿！edge，火狐都没有问题，就是谷歌出问题，最后在一个贴吧老哥那里找到的解决办法——-》修改电脑时区</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li><p>先将自己的时区随便设置一个，这里要先关掉自动设置时区，然后才能自己设置时区</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094157.png"></p></li><li><p>接着再将本地的时区改回来，我这里是东八区，于是我在改回东八区，至此问题解决</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094338.png"></p></li></ul>]]></content>
    
    
    <summary type="html">谷歌浏览器格式化时间与本地时区相差16小时</summary>
    
    
    
    <category term="小技巧" scheme="https://i-fire.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="chrome" scheme="https://i-fire.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>我爱签到网使用教程</title>
    <link href="https://i-fire.top/post/52sign.html"/>
    <id>https://i-fire.top/post/52sign.html</id>
    <published>2021-01-17T02:43:30.000Z</published>
    <updated>2021-01-17T03:16:11.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我爱签到网使用教程"><a href="#我爱签到网使用教程" class="headerlink" title="我爱签到网使用教程"></a>我爱签到网使用教程</h1><h3 id="平台介绍"><a href="#平台介绍" class="headerlink" title="平台介绍"></a>平台介绍</h3><p>一个集成了各大平台打卡签到功能的系统，基于springboot和layui开发，大部分功能完全免费</p><h3 id="目前已经有的功能"><a href="#目前已经有的功能" class="headerlink" title="目前已经有的功能"></a>目前已经有的功能</h3><ul><li>学习通签到<ul><li>普通签到</li><li>位置签到</li><li>手势签到</li></ul></li><li>网易云打卡<ul><li>云贝打卡</li><li>每日听歌300首</li></ul></li></ul><p><strong>PS：只要保持各大平台的密码正确，完全可以实现自动化签到，彻底解放双手</strong></p><p><strong>PS：后续会添加更多自动化功能</strong></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>打卡我爱签到网网址：<a href="https://52sign.top/">https://52sign.top/</a></p></li><li><p>点击注册用户，点击这两处都行</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100006.png"></p></li><li><p>按照要求输入相应的信息即可，然后点击注册</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100213.png"></p></li><li><p>注册成功后会收到一封激活邮箱的邮件，只有先激活邮箱，才能登陆网站</p></li><li><p>然后登陆到网站里面，看到当前页面说明注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102141.png"></p></li><li><p>登陆成功后即可开始使用（以学习通签到为例）</p><ul><li><p>首先需要添加一个学习通账号</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102605.png"></p></li></ul></li><li><p>添加完毕后获取学习通账户的所有课程</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102839.png"></p><p>选择刚才添加的学习通账号，然后获取到账号中的所有的课程后</p><ul><li><p>为课程添加签到任务</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103156.png"></p></li><li><p>查看签到所有的签到任务</p><p><img src="C:\Users\15061\AppData\Roaming\Typora\typora-user-images\image-20210117103344648.png"></p></li><li><p>查看学习通签到日志</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103415.png"></p></li></ul><p><strong>注意：数据库中的数据没10分钟才会同步一次，有时候日志里面没有数据不代表没签上，具体以学习通是否签到为准</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>至此演示了学习通签到任务的添加流程，网易云也是大同小异，请自己研究一下！！</p>]]></content>
    
    
    <summary type="html">全自动打卡，彻底解放你的双手，让您专注于手头的任务上</summary>
    
    
    
    <category term="项目" scheme="https://i-fire.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://i-fire.top/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="我爱签到网" scheme="https://i-fire.top/tags/%E6%88%91%E7%88%B1%E7%AD%BE%E5%88%B0%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>警醒</title>
    <link href="https://i-fire.top/post/warn.html"/>
    <id>https://i-fire.top/post/warn.html</id>
    <published>2021-01-15T00:47:12.000Z</published>
    <updated>2021-01-15T00:55:18.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="警戒"><a href="#警戒" class="headerlink" title="警戒"></a>警戒</h1><p>今天是2021年1月15号，谨以此文章记录一年前的今天我在某重大战役中的胜利</p><p><strong>凡事必须三思而后行</strong></p>]]></content>
    
    
    <summary type="html">警戒</summary>
    
    
    
    <category term="大事记" scheme="https://i-fire.top/categories/%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
