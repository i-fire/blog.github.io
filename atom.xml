<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fire&#39;s Blog</title>
  
  <subtitle>念念不忘，必有回响</subtitle>
  <link href="https://i-fire.top/atom.xml" rel="self"/>
  
  <link href="https://i-fire.top/"/>
  <updated>2021-03-18T08:07:07.616Z</updated>
  <id>https://i-fire.top/</id>
  
  <author>
    <name>烟火小兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树的存储结构</title>
    <link href="https://i-fire.top/post/treeModel.html"/>
    <id>https://i-fire.top/post/treeModel.html</id>
    <published>2021-03-18T08:04:49.000Z</published>
    <updated>2021-03-18T08:07:07.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h3 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h3><p>二叉树的顺序存储结构，指的是使用数组存储二叉树，但是需要注意的是顺序存储只适合用于存储完全二叉树。<br><strong>因此：如果我们想存储普通的二叉树，需要提前将普通二叉树转换为完全二叉树</strong></p><blockquote><p>满二叉树也可以使用顺序存储。要知道，满二叉树也是完全二叉树，因为它满足完全二叉树的所有特征。</p></blockquote><p>普通二叉树转换成完全二叉树的方法很简单，只需要给二叉树额外的添加一些节点，经其拼凑成完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081507.png"></p><p>完全二叉树的顺序存储，仅需要从根节点开始，按照层次依次将树中节点存储到数组中<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081908.png"></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318081958.png"></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318082023.png"></p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>从二叉树的顺序存储中可以看出，二叉树实际上不适合用数组进行存储，因为<strong>并不是每个二叉树都是完全二叉树</strong>，普通二叉树使用顺序表多多少少会存在浪费空间的现象，因此引入了二叉树的链式存储结构。<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083131.png"></p><p>如图所示，这是一个普通的二叉树，若将其采用链式存储结构，则需要从树的根节点开始，将各个节点及其左右孩子使用链表存储即可<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083321.png"></p><p>由图 2 可知，采用链式存储二叉树时，其节点结构由 3 部分构成（如图 3 所示）：</p><ul><li>指向左孩子节点的指针（Lchild）；</li><li>节点存储的数据（data）；</li><li>指向右孩子节点的指针（Rchild）；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210318083845.png"></p>]]></content>
    
    
    <summary type="html">数据结构，树，树的存储结构</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://i-fire.top/post/binaryTree.html"/>
    <id>https://i-fire.top/post/binaryTree.html</id>
    <published>2021-03-13T06:53:29.000Z</published>
    <updated>2021-03-13T06:56:23.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉树：每个节点至多只能有两个子树（即不存在度大于2的节点），其子树（也称为二叉树）有左右之分且次序不能任意颠倒的树称为二叉树</p><p><strong>二叉树的五种形态</strong></p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313140247.png"></p><ul><li>（a）：空二叉树</li><li>（b）：只有根节点的二叉树</li><li>（c）：右子树为空的二叉树</li><li>（d）：左右子树均为非空的二叉树</li><li>（e）：左子树为空的二叉树</li></ul><h3 id="完全二叉树-满二叉树"><a href="#完全二叉树-满二叉树" class="headerlink" title="完全二叉树/满二叉树"></a>完全二叉树/满二叉树</h3><ul><li><p>满二叉树定义：如果二叉树中除了叶子节点之外的所有节点的度都为2，则此二叉树称为满二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313144534.png"></p></li><li><p>完全二叉树定义：如果二叉树去掉最后一层节点为满二叉树且最后一层的节点从左到右依次分布，则此二叉树称为完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313144737.png"></p></li></ul><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>在二叉树的第i（i&gt;=1）层上，至多有2<sup>i-1</sup>个节点</li><li>深度为k（k&gt;=1）的二叉树至多有2<sup>k</sup>-1个节点</li><li>对任意一颗二叉树T，如果其叶子节点树为n<sub>0</sub>，度为2的节点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1</li><li>具有n个节点的<strong>完全二叉树</strong>的深度为[log<sub>2</sub><sup>n</sup>]+1，[x]表示不大于x的最大整数</li><li>对于一颗有n个节点的<strong>完全二叉树</strong>（其深度为[log<sub>2</sub><sup>n</sup>]+1）的节点按照层序进行遍历（从第1层到第[log<sub>2</sub><sup>n</sup>]+1层，每层从左到右）对任一节点有<ul><li>如果i=1，则节点是二叉树的根，无双亲</li><li>如果i&gt;1则其双亲节点是[i/2]</li><li>如果2i&gt;n，则节点i没有左孩子（节点i为叶子节点），否则其左孩子是节点2i</li><li>如果2i+1&gt;n，则节点i没有右孩子，否则其右孩子是节点2n+1</li></ul></li></ul>]]></content>
    
    
    <summary type="html">树，fire&#39;s blog,数据结构与算法</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://i-fire.top/post/tree.html"/>
    <id>https://i-fire.top/post/tree.html</id>
    <published>2021-03-13T06:53:29.000Z</published>
    <updated>2021-03-13T06:55:53.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树是n（n&gt;=0）个节点构成的集合</p><ul><li>当n=0时，称为空树</li><li>在一颗树中<ul><li>有且仅有一个特定的节点称为<strong>根</strong></li><li>当n&gt;1时，其余节点可以分为m（m&gt;0）个互不相交的有限集T<sub>1</sub>,T<sub>2</sub>…..T<sub>m</sub>，其中每一个集合又是一棵树，并且称为根的子树</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313080552.png"></p><h3 id="树的表示形式"><a href="#树的表示形式" class="headerlink" title="树的表示形式"></a>树的表示形式</h3><p>（a）嵌套集合表示树：用集合和嵌套的集合表示树，如图 6-2（a）； </p><p>（b）广义表表示树：根作为由子树森林组成的表的名字写在表的左边，如图 6-2（b）； </p><p>（c）凹入法表示树：如图 6-2（c）</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210313080853.png"></p><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><ul><li>节点：树的节点包含一个数据元素以及若干指向其子树的分支</li><li>节点的度：节点拥有的子树个数</li><li>树的度：树内各节点的度的最大值</li><li>叶子节点（终端节点）：度为0的节点称为叶子节点或者终端节点，度不为0的称为非终端节点或者分支节点</li><li>节点的孩子，双亲：节点的子树称为节点的孩子，相应的该节点称为孩子的双亲</li><li>兄弟节点：同一双亲的孩子节点直接称为兄弟节点</li><li>树的深度：树中节点的最大层次称为树的深度</li><li>节点的祖先：从根到该节点所经分支上的所有的节点</li><li>节点的子孙：以该节点为根的子树中的任一节点</li><li>结点的堂兄弟：其双亲在同一层的结点互为堂兄弟。</li><li>森林：m（m≥0）棵互不相交的树的集合。</li></ul>]]></content>
    
    
    <summary type="html">树，fire&#39;s blog,数据结构与算法</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构与算法" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://i-fire.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>串的模式匹配算法</title>
    <link href="https://i-fire.top/post/BfKmp.html"/>
    <id>https://i-fire.top/post/BfKmp.html</id>
    <published>2021-03-11T23:47:02.000Z</published>
    <updated>2021-03-11T23:49:37.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h1><p>串的模式匹配，简要的来说就是判断两个串之间是否有主串和子串的关系实现串的模式匹配的算法主要有以下两种：</p><ul><li>普通的模式匹配算法；</li><li>快速匹配算法</li></ul><h3 id="普通模式匹配算法（BF算法）"><a href="#普通模式匹配算法（BF算法）" class="headerlink" title="普通模式匹配算法（BF算法）"></a>普通模式匹配算法（BF算法）</h3><p>BF算法又称为暴力穷举法，他的实现过程没有任何的技巧，就是简单粗暴的拿一个串的字符和另外一个串中的字符一一比较<br>例如，使用普通模式匹配算法判断串 A（”abcac”）是否为串 B（”ababcabacabab”）子串的判断过程如下：<br>首先，将串 A 与串 B 的首字符对齐，然后逐个判断相对的字符是否相等，如<a href="http://data.biancheng.net/view/200.html">图</a> 1 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081817.png"></p><p>图 1 中，由于串 A 与串 B 的第 3 个字符匹配失败，因此需要将串 A 后移一个字符的位置，继续同串 B 匹配，如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081848.png"></p><p>图 2 中可以看到，两串匹配失败，串 A 继续向后移动一个字符的位置，如图 3 所示<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228081945.png"></p><p>图 3 中，两串的模式匹配失败，串 A 继续移动，一直移动至图 4 的位置才匹配成功：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210228082012.png"></p><p>由此，串 A 与串 B 以供经历了 6 次匹配的过程才成功，通过整个模式匹配的过程，证明了串 A 是串 B 的子串（串 B 是串 A 的主串）。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>* ch;<span class="comment">//存放串</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(str* p, str* c)</span></span>;<span class="comment">//获取一个串在另外一个串中的位置，匹配成功返回所在位置，匹配失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">str* strOne = (<span class="built_in">malloc</span>)(<span class="keyword">sizeof</span>(str));</span><br><span class="line">strOne-&gt;length = <span class="number">7</span>;</span><br><span class="line">strOne-&gt;ch = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">str* strTwo = (<span class="built_in">malloc</span>)(<span class="keyword">sizeof</span>(str));</span><br><span class="line">strTwo-&gt;length = <span class="number">3</span>;</span><br><span class="line">strTwo-&gt;ch = <span class="string">&quot;efg&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bf(strOne, strTwo));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(str* p, str* c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; p-&gt;length &amp;&amp; j &lt; c-&gt;length) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;ch)[i] == (c-&gt;ch)[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == c-&gt;length) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：代码中j的作用：j不仅记录着循环体重串c中数组的下标，同时j还有记录串p和串c同时循环了多少次的问题，i-j即表示让i回到原来的位置上，i-j+1则表示让i移动到串p数组中当前元素的下一个元素的位置上</strong></p><h3 id="快速匹配算法（KMP算法）"><a href="#快速匹配算法（KMP算法）" class="headerlink" title="快速匹配算法（KMP算法）"></a>快速匹配算法（KMP算法）</h3><p><strong>暂时还未想好怎么写文章</strong></p>]]></content>
    
    
    <summary type="html">串的模式匹配算法，kmp，bf</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="串" scheme="https://i-fire.top/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>串</title>
    <link href="https://i-fire.top/post/str.html"/>
    <id>https://i-fire.top/post/str.html</id>
    <published>2021-02-27T09:58:58.000Z</published>
    <updated>2021-02-27T10:00:31.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>串（字符串）是由零个或者多个字符组成的有限序列，一般记为S=’a<sub>1</sub>a<sub>2</sub>…..a<sub>n</sub>‘<br>从严格意义上来说，串的结构也是一种线性存储结构，因为字符串中的字符之间也是具有“一对一”的逻辑关系，只不过与之前的线性结构不同的是，串只能存储字符型数据</p><h3 id="串的基本术语"><a href="#串的基本术语" class="headerlink" title="串的基本术语"></a>串的基本术语</h3><ul><li>空串：存储0个字符的串，例如S=””</li><li>空格串：只包含空格字符的串，例如：“        ”</li><li>子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = “shujujiegou”，b = “shuju”，由于 a 中也包含 “shuju”，因此串 a 和串 b 是主串和子串的关系；</li></ul><p><strong>注意：需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 “shujiejugou” 和 “shuju” 就不是主串和子串的关系。</strong></p><ul><li>另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。<strong>例如，串 a = “shujujiegou”，串 b = “jiegou”，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 ‘j’ 的位置是 6</strong></li></ul><h3 id="串的定长顺序存储结构"><a href="#串的定长顺序存储结构" class="headerlink" title="串的定长顺序存储结构"></a>串的定长顺序存储结构</h3><p>串的定长顺序存储结构，可以简单地理解为采用 “固定长度的顺序存储结构” 来存储字符串，因此限定了其底层实现只能使用静态数组。<br>使用定长顺序存储结构存储字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。<br>例如，采用定长顺序存储结构存储 “data.biancheng.net”，通过目测得知此字符串长度为 18（不包含结束符 ‘\0’），因此我们申请的数组空间长度至少为 18，用 C 语言表示为：</p><blockquote><p>char str[18] = “data.biancheng.net”;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">&quot;data.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串的堆分配存储结构"><a href="#串的堆分配存储结构" class="headerlink" title="串的堆分配存储结构"></a>串的堆分配存储结构</h3><p><a href="http://data.biancheng.net/view/175.html">串</a>的堆分配存储，其具体实现方式是采用动态<a href="http://data.biancheng.net/view/181.html">数组</a>存储字符串。<br>通常，编程语言会将程序占有的内存空间分成多个不同的区域，程序包含的数据会被分门别类并存储到对应的区域。拿 C 语言来说，程序会将内存分为 4 个区域，分别为堆区、<a href="http://data.biancheng.net/view/169.html">栈</a>区、数据区和代码区，其中的堆区是本节所关注的。<br>与其他区域不同，堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。<br>C 语言中使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。例如：</p><blockquote><p>char * a = (char*)malloc(5*sizeof(char));</p></blockquote><p>此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。<br>动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）：</p><blockquote><p>a = (char*)realloc(a, 10*sizeof(char));</p></blockquote><p>通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。<br>一个完整的示例，以便对串的堆分配存储有更清楚地认识。该程序可实现将两个串（”data.bian” 和 “cheng.net”）合并为一个串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * a1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * a2 = <span class="literal">NULL</span>;</span><br><span class="line">    a1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(a1, <span class="string">&quot;data.bian&quot;</span>);<span class="comment">//将字符串&quot;data.bian&quot;复制给a1</span></span><br><span class="line">    a2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(a2, <span class="string">&quot;cheng.net&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> lengthA1 = <span class="built_in">strlen</span>(a1);<span class="comment">//a1串的长度</span></span><br><span class="line">    <span class="keyword">int</span> lengthA2 = <span class="built_in">strlen</span>(a2);<span class="comment">//a2串的长度</span></span><br><span class="line">    <span class="comment">//尝试将合并的串存储在 a1 中，如果 a1 空间不够，则用realloc动态申请</span></span><br><span class="line">    <span class="keyword">if</span> (lengthA1 &lt; lengthA1 + lengthA2) &#123;</span><br><span class="line">        a1 = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(a1, (lengthA1 + lengthA2+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个串到 a1 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lengthA1; i &lt; lengthA1 + lengthA2; i++) &#123;</span><br><span class="line">        a1[i] = a2[i - lengthA1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//串的末尾要添加 \0，避免出错</span></span><br><span class="line">    a1[lengthA1 + lengthA2] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a1);</span><br><span class="line">    <span class="comment">//用完动态数组要立即释放</span></span><br><span class="line">    <span class="built_in">free</span>(a1);</span><br><span class="line">    <span class="built_in">free</span>(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，程序中给 a1 和 a2 赋值时，使用了 strcpy 复制函数。这里不能直接用 a1 =”data.biancheng”，程序编译会出错，报错信息为 “没有 malloc 的空间不能 free”。因为 strcpy 函数是将字符串复制到申请的存储空间中，而直接赋值是字符串存储在别的内存空间（本身是一个常量，放在数据区）中，更改了指针 a1 和 a2 的指向，也就是说，之前动态申请的存储空间虽然申请了，结果还没用呢就丢了。</p></blockquote><h3 id="串的块链存储"><a href="#串的块链存储" class="headerlink" title="串的块链存储"></a>串的块链存储</h3><p><a href="http://data.biancheng.net/view/175.html">串</a>的块链存储，指的是使用<a href="http://data.biancheng.net/view/160.html">链表</a>结构存储字符串。<br>本节实现串的块链存储使用的是无头节点的单链表。当然根据实际需要，你也可以自行决定所用链表的结构（<a href="http://data.biancheng.net/view/166.html">双向链表</a>还是单链表，有无头节点）。<br>我们知道，单链表中的 “单” 强调的仅仅是链表各个节点只能有一个指针，并没有限制数据域中存储数据的具体个数。因此在设计链表节点的结构时，可以令各节点存储多个数据。<br>例如，<a href="http://data.biancheng.net/view/200.html">图</a> 1 所示是用链表存储字符串 <code>shujujiegou</code>，该链表各个节点中可存储 1 个字符：</p><p><img src="C:\Users\15061\AppData\Roaming\Typora\typora-user-images\image-20210227084947458.png" alt="image-20210227084947458"></p><p>同样，图 2 设置的链表各节点可存储 4 个字符：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210227085012.png"></p><p>从图 2 可以看到，使用链表存储字符串，其最后一个节点的数据域不一定会被字符串全部占满，对于这种情况，通常会用 ‘#’ 或其他特殊字符（能与字符串区分开就行）将最后一个节点填满。<br>用块链结构存储字符串时，怎样确定链表中节点存储数据的个数呢？？？链表各节点存储数据个数的多少可参考以下几个因素：</p><ul><li><p>串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑；</p></li><li><p>程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各节点存储数据的数量；反之，就需要再结合其他因素。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> linkNum 3<span class="comment">//全局设置链表中节点存储数据的个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[linkNum]; <span class="comment">//数据域可存放 linkNum 个数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> * <span class="title">next</span>;</span> <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;link; <span class="comment">// nk为节点名，每个节点都是一个 link 结构体</span></span><br><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">(link * head, <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLink</span><span class="params">(link * head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link * head = <span class="literal">NULL</span>;</span><br><span class="line">    head = initLink(head, <span class="string">&quot;data.biancheng.net&quot;</span>);</span><br><span class="line">    displayLink(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化链表，其中head为头指针，str为存储的字符串</span></span><br><span class="line"><span class="function">link * <span class="title">initLink</span><span class="params">(link * head, <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="comment">//根据字符串的长度，计算出链表中使用节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> num = length/linkNum;</span><br><span class="line">    <span class="keyword">if</span> (length%linkNum) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建并初始化首元节点</span></span><br><span class="line">    head = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    link *temp = head;</span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j&lt;linkNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i*linkNum + j &lt; length) &#123;</span><br><span class="line">                temp-&gt;a[j] = str[i*linkNum + j];</span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp-&gt;a[j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*linkNum + j &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            link * newlink = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">            newlink-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            temp-&gt;next = newlink;</span><br><span class="line">            temp = newlink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLink</span><span class="params">(link * head)</span> </span>&#123;</span><br><span class="line">    link * temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkNum; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, temp-&gt;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，串</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="串" scheme="https://i-fire.top/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://i-fire.top/post/queue.html"/>
    <id>https://i-fire.top/post/queue.html</id>
    <published>2021-02-26T06:13:59.000Z</published>
    <updated>2021-02-26T06:15:27.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列：和栈一样，也是一种对数据的<strong>存取</strong>有严格要求的线性存储结构<br>与栈不同的是，队列的两端都要开口，同时要求数据只能从一端进，从另一端出<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226084414.png"></p><blockquote><p>通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。不仅如此，队列中数据的进出要遵循 “先进先出” 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p></blockquote><blockquote><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><h3 id="队列的顺序表示"><a href="#队列的顺序表示" class="headerlink" title="队列的顺序表示"></a>队列的顺序表示</h3><p>顺序队列的实现使用的是<strong>数组</strong>，为了满足顺序队列中数据从队尾进入，从队头出且先进先出的要求，因此我们还需要两个指针（top和rear）分别指向顺序队列中的队头元素和队尾元素<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226084819.png"></p><p>因为顺序队列初始状态没有存储任何的元素，因此top指针和rear指针重合<br>在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。<br>例如，在图 1 基础上将 <code>&#123;1,2,3,4&#125;</code> 用顺序队列存储的实现操作如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085142.png"></p><p>在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085225.png"></p><p>但是如果仔细观察这样的操作就会发现这样的操作是有问题的<br>先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出（假上溢）错误；</li></ul><p>针对这样的假上溢，我们可以将原来的顺序表制作成一个环形结构（循环队列）</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210226085649.png"></p><p>这只是一个逻辑结构，在实际的存储中我们依然使用的是数组这样的线性结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];<span class="comment">//存放数据的数组</span></span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//队头元素下标</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//队尾元素下标</span></span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">initQueue</span><span class="params">()</span></span>;<span class="comment">//获取一个队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popQueue</span><span class="params">(<span class="built_in">queue</span>* p)</span></span>;<span class="comment">//队列出队一个元素，同时返回这个出队的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushQueue</span><span class="params">(<span class="built_in">queue</span>* p, <span class="keyword">int</span> e)</span></span>;<span class="comment">//队列入队一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>* p = initQueue();</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">pushQueue(p,<span class="number">1</span>);</span><br><span class="line">popQueue(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>* temp = (<span class="built_in">queue</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">temp-&gt;top = <span class="number">0</span>;</span><br><span class="line">temp-&gt;rear = temp-&gt;top;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建队列失败===========&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popQueue</span><span class="params">(<span class="built_in">queue</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列出队失败========&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rear == p-&gt;top) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;队列出队失败=========&gt;队列为空\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = p-&gt;data[p-&gt;top];</span><br><span class="line">p-&gt;top = (p-&gt;top + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushQueue</span><span class="params">(<span class="built_in">queue</span>* p, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队失败===========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;rear + <span class="number">1</span>) % MAXSIZE == p-&gt;top) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;入队失败=================&gt;队满！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data[p-&gt;top] = e;</span><br><span class="line">p-&gt;rear = (p-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，队列</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="https://i-fire.top/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://i-fire.top/post/satck.html"/>
    <id>https://i-fire.top/post/satck.html</id>
    <published>2021-02-25T06:22:28.000Z</published>
    <updated>2021-02-25T06:24:45.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>和<strong>顺序表，链表</strong>一样，栈也是用来存储逻辑关系为一对一数据的线性结构存储</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225082359.png"></p><p>如图所示，栈的存储结构与之前的线性结构有所差异，因为栈对于数据的存和取的过程有特殊的要求</p><ul><li>栈只能从表的一端存取数据，另一端是封闭的</li><li>在栈中，无论是存储数据还是取数据，都必须遵循先进后厨的原则，即最先进栈的元素最后出栈</li></ul><p>因此，我们可以给栈下一个定义，即栈是一种<strong>只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构</strong><br>通常。栈的开口端被称为<strong>栈顶</strong>，相应的，封口端被称为<strong>栈底</strong>，因此，栈顶元素指的就是距离栈顶最近的元素拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225082813.png"></p><h3 id="进栈和出栈"><a href="#进栈和出栈" class="headerlink" title="进栈和出栈"></a>进栈和出栈</h3><p>基于栈的结构特点，在实际的应用中，通常只会对栈执行以下的两种操作</p><ul><li>向栈中添加元素，此过程被称为<strong>进栈</strong>（入栈或者压栈）</li><li>从栈中取出指定的元素，此过程称为<strong>出站</strong>（弹栈）</li></ul><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>基于栈结构对数据存取采用 “先进后出” 原则的特点，它可以用于实现很多功能。</p><p>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：</p><ul><li>重新搜索找到页面 A；</li><li>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。<br>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。</li></ul><p>不仅如此，栈存储结构还可以帮我们检测代码中的<a href="http://data.biancheng.net/view/87.html">括号匹配</a>问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。</p><p>同时，栈结构还可以实现数值的<a href="http://data.biancheng.net/view/86.html">进制转换</a>功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。</p><h3 id="栈的顺序实现"><a href="#栈的顺序实现" class="headerlink" title="栈的顺序实现"></a>栈的顺序实现</h3><p><strong>顺序栈</strong>，即用<strong>顺序表</strong>实现栈存储结构。通过前面的学习我们知道，使用栈存储结构操作数据元素必须遵守 “先进后出” 的原则<br>当我们使用顺序表（a数组）存储{1,2,3,4}时，应该是这个样的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225085253.png"></p><p>同样，使用栈存储{1,2,3,4}时，应该是这个样的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225085443.png"></p><p>通过这两个图对比介意发现，使用顺序表模拟栈的结构很容易，只需要将数据从数组下标为0的位置依次存储即可</p><h4 id="栈的顺序结构"><a href="#栈的顺序结构" class="headerlink" title="栈的顺序结构"></a>栈的顺序结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10<span class="comment">//定义顺序栈的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span>* top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span>* base;<span class="comment">//栈底元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="实现顺序栈"><a href="#实现顺序栈" class="headerlink" title="实现顺序栈"></a>实现顺序栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 3<span class="comment">//定义顺序栈的最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span>* top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span>* base;<span class="comment">//栈底元素的指针</span></span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>* <span class="title">initStack</span><span class="params">()</span></span>;<span class="comment">//获取一个栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isStackEmpty</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//判断栈循序栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInStack</span><span class="params">(<span class="built_in">stack</span>* s, <span class="keyword">int</span> e)</span></span>;<span class="comment">//将一个元素入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//顺序栈出栈，同时返回出出栈的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//销毁顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearStack</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//清空顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStackLength</span><span class="params">(<span class="built_in">stack</span>* s)</span></span>;<span class="comment">//求顺序栈的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>* s = initStack();</span><br><span class="line">addInStack(s, <span class="number">1</span>);</span><br><span class="line">addInStack(s, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈的长度是===========&gt;%d\n&quot;</span>,getStackLength(s));</span><br><span class="line">addInStack(s, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈=========&gt;%d\n&quot;</span>, popStack(s));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈是否为空===============&gt;%d\n&quot;</span>, isStackEmpty(s));</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>* <span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>* p = (<span class="built_in">stack</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取一个栈失败============&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;base = &amp;(p-&gt;data[<span class="number">0</span>]);</span><br><span class="line">p-&gt;top = &amp;(p-&gt;data[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isStackEmpty</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断顺序栈是否为空错误=============&gt;参数错误]\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInStack</span><span class="params">(<span class="built_in">stack</span>* s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈入栈失败============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == MAXSIZE) &#123;<span class="comment">//说明当前栈已经满了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈添加元素失败===============&gt;栈满了\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">*(s-&gt;top) = e;</span><br><span class="line">s-&gt;top = s-&gt;top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈失败=============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top - s-&gt;base == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;顺序栈出栈失败============&gt;栈为空\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top = s-&gt;top - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *(s-&gt;top);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁顺序栈失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearStack</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空顺序栈失败=================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;top = s-&gt;base;<span class="comment">//直接将栈顶指针指向栈底，这样就可以了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStackLength</span><span class="params">(<span class="built_in">stack</span>* s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取顺序栈长度失败========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (s-&gt;top - s-&gt;base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式结构（链栈）"><a href="#栈的链式结构（链栈）" class="headerlink" title="栈的链式结构（链栈）"></a>栈的链式结构（链栈）</h3><p>链栈：用链表实现栈的存储结构<br>链栈的实现思路同<strong>顺序栈</strong>类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210225140305.png"></p><blockquote><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p></blockquote><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li><li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；</li><li>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</li></ul><h4 id="链栈的结构"><a href="#链栈的结构" class="headerlink" title="链栈的结构"></a>链栈的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;弹栈元素：%d &quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈顶元素：%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;栈已空\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈内没有元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，栈</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="栈" scheme="https://i-fire.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>双向链表</title>
    <link href="https://i-fire.top/post/twoWayLinkedList.html"/>
    <id>https://i-fire.top/post/twoWayLinkedList.html</id>
    <published>2021-02-23T11:04:37.000Z</published>
    <updated>2021-02-23T11:08:57.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>在之前学习的的链表中，无论是静态链表或者是动态链表，在他们的每一个节点中值包含一个指针（游标），而且指针都是同一个指向后继节点，通常称这类链表为单向链表（或单链表）。，使用这些单链表虽然可以解决逻辑关系为<strong>一对一</strong>数据的存储问题，但是在解决某些特殊问题的时候，这些链表并不是效率最优的存储结构，比如说，在某些情况下需要大量的查找某节点的前驱节点，使用单链表无疑是很繁琐的，因为单链表更适合的是<strong>从前往后找</strong>并，<strong>从后往前找</strong>并不是他的强项！<br>对于逆向查找（从后往前进行查找）相关的问题，我们可以使用<strong>双向链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>双向链表，简称双链表。从名字上理解双向链表，即链表是 “双向” 的<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082035.png"></p><p>所谓双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要，可以为最后一个节点再设置一个“头指针”。<br>根据上图可知，双向链表中各个节点包含以下3部分信息</p><ul><li>指针域：指向当前节点的前驱节点</li><li>数据域：存储数据元素</li><li>指针域：用于指向当前节点的直接后继节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210223082258.png"></p><h3 id="双向链表的代码实现"><a href="#双向链表的代码实现" class="headerlink" title="双向链表的代码实现"></a>双向链表的代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">//定义双向链表的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">pre</span>;</span><span class="comment">//当前节点的前驱节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twoWayLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//当前节点的后继节点指针</span></span><br><span class="line">&#125; tWLLNode;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span></span>;<span class="comment">//获取一个双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//判断双向链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的头部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在双向链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在中间添加一个元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//遍历双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//获取双向链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取节点的值并返回，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//销毁整个双向链表包括头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span></span>;<span class="comment">//删除双向链表尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除节点,index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">tWLLNode* head = initTwoWayLinkedList();</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">19</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">1</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">2</span>);</span><br><span class="line">addEleTwoLinkedListTail(head, <span class="number">190</span>);</span><br><span class="line">addELeTwoWayLinkedList(head, <span class="number">3</span>);</span><br><span class="line">addEleTwoLinkedListByIndex(head, <span class="number">2</span>, <span class="number">89</span>);</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line">deleteTwoWayLinkedListByIndex(head, <span class="number">5</span>);</span><br><span class="line">outTwoWayLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表是否为空==========================&gt;%d\n&quot;</span>, isTwoWayLinkedListEmpty(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表的长度是=======================&gt;%d\n&quot;</span>, getTwoWayLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表中第199个元素是=============&gt;%d\n&quot;</span>, getEleInTwoWayLinkedListByindex(head, <span class="number">199</span>));</span><br><span class="line"><span class="comment">//destoryTwoWayLinkedList(head);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tWLLNode* <span class="title">initTwoWayLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tWLLNode* head = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));<span class="comment">//构造出双向链表的头节点，有了这个头节点可以更加方便的处理双向链表</span></span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建双向链表失败=================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTwoWayLinkedListEmpty</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断双向链表是否为空失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addELeTwoWayLinkedList</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表头插入元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表插入元素失败====================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line">tWLLNode* temp = head-&gt;next;<span class="comment">//原来双向链表中的第一个节点</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;<span class="comment">//说明是第一次添加节点</span></span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历双向链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向循环链表中第%d个元素是=============&gt;%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListTail</span><span class="params">(tWLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在双向链表的尾部添加元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;<span class="comment">//第一次添加节点，直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;双向链表尾部添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;pre = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleTwoLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败==============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//直接调用头添加</span></span><br><span class="line">addELeTwoWayLinkedList(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i || p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败================&gt;元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;<span class="comment">//当前节点的前一个节点</span></span><br><span class="line">tWLLNode* node = (tWLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tWLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index添加元素失败================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">node-&gt;pre = temp;</span><br><span class="line">node-&gt;next = p;</span><br><span class="line">p-&gt;pre = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwoWayLinkedListLength</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取双向链表长度失败================参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleInTwoWayLinkedListByindex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取双向链表的值失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; i &lt; index) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span> || index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index获取节点值失败=======================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryTwoWayLinkedList</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁双向链表失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line">tWLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListHead</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除首元节点失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//判断是不是只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;pre = head;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListTail</span><span class="params">(tWLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除双向链表尾结点失败=================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tWLLNode* temp = p-&gt;pre;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTwoWayLinkedListByIndex</span><span class="params">(tWLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">deleteTwoWayLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tWLLNode* p = head;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点错误=====================&gt;节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//说明是最后一个节点</span></span><br><span class="line">p-&gt;pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next-&gt;pre = p-&gt;pre;</span><br><span class="line">p-&gt;pre-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，双向链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="双向链表" scheme="https://i-fire.top/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单向循环链表</title>
    <link href="https://i-fire.top/post/circularLinkedList.html"/>
    <id>https://i-fire.top/post/circularLinkedList.html</id>
    <published>2021-02-22T07:44:15.000Z</published>
    <updated>2021-02-22T07:46:57.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>循环链表是一种头尾相接的链表，他的最后一个指针域指向头节点，形成一个环<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221083642.png"></p><p><strong>注意：</strong>虽然循环链表成环状，，但是本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等等，循环链表和普通的链表相比，唯一不同的就是循环链表首尾相连（尾结点的指针域永远指向首元节点），其他都完全一样。</p><h3 id="单向循环链表代码实现"><a href="#单向循环链表代码实现" class="headerlink" title="单向循环链表代码实现"></a>单向循环链表代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">circularLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//存放链表节点的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cLLNode</span>* <span class="title">next</span>;</span><span class="comment">//链表节点的指针域</span></span><br><span class="line">&#125;cLLNode;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span></span>;<span class="comment">//对单向循环链表进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//判断单向循环链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向循环链表尾部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向单向链表头部插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单向循环链表第一次插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//遍历链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//将单向循环链表的所有的节点全部清空，只保留头指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//获取单向循环链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个元素前插入一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的首元节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span></span>;<span class="comment">//删除单向循环链表的尾结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index删除单向循环链表的节点，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//根据index获取元素的值，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">cLLNode* head = initCircularLinkedList();</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">119</span>);</span><br><span class="line">addEleInCircularLinkedList(head, <span class="number">12</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">13</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">14</span>);</span><br><span class="line">addEleInCircularLinkedListHead(head, <span class="number">15</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">addEleInCircularLinkedListByIndex(head, <span class="number">7</span>, <span class="number">10000</span>);</span><br><span class="line">outCircularLinkedList(head);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表为的长度是%d\n&quot;</span>, getCircularLinkedListLength(head));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表的第8个元素是%d&quot;</span>,getEleCircularLinkedListByIndex(head,<span class="number">8</span>));</span><br><span class="line">clearCircularLinkedList(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cLLNode* <span class="title">initCircularLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造单向循环链表的头节点</span></span><br><span class="line">cLLNode* head = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表创建失败==================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">circularLinkedListIsEmpty</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断单向循环链表是否为空失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedList</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;<span class="comment">//说明是第一次添加元素</span></span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next) &#123;<span class="comment">//找到单向循环链表的最后一个节点</span></span><br><span class="line"></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">temp-&gt;next = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListHead</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表头插入元素失败===============&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">firstCircularLinkedListEleadd(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line">cLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">temp-&gt;next = p;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头插入元素失败===========&gt;空间不足\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstCircularLinkedListEleadd</span><span class="params">(cLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第一次插入失败========&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败=========&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历链表失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;<span class="comment">//单向循环链表达到表尾的条件是最后一个指针域指向首元节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表中的第%d个元素是%d\n&quot;</span>, i, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCircularLinkedList</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清空单链表失败=====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">temp = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCircularLinkedListLength</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环单链表插入元素失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头插入</span></span><br><span class="line">addEleInCircularLinkedListHead(head, e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index插入元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || (p-&gt;next == head-&gt;next &amp;&amp; i + <span class="number">1</span> != index)) &#123;<span class="comment">//判断是否找到当前元素的前一个元素，!p成立的的话说明当前单向循环链表是空的，如果后面 (p-&gt;next == head-&gt;next &amp;&amp; i + 1 != index)同时成立的话说明就是没有找到节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素错误=======================&gt;index对应的节点不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里说明已经找到当前的节点的前一个节点</span></span><br><span class="line">cLLNode* temp = (cLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cLLNode));</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;插入元素失败==========================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;data);</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListHead</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除单向循环链表的首元节点失败===================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//单向循环链表的第二个节点</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != head-&gt;next)<span class="comment">//查找最后一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* node = p-&gt;next;<span class="comment">//需要删除的首元节点</span></span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line"><span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListTail</span><span class="params">(cLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单向循环链表尾删除失败================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line">cLLNode* temp = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//说明只有一个节点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next != head-&gt;next)<span class="comment">//找到需要删除的节点的的前一个节点</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">temp = p-&gt;next;<span class="comment">//因为不允许使用p-&gt;next-&gt;next，所以多增加一个temp变量，效果和p-&gt;next-&gt;next一样，方便找到最后一个节点的前一个节点，这个temp变量就是最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || head-&gt;next == <span class="literal">NULL</span> || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除节点失败==========================&gt;参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//说明是头删除</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == p) &#123;<span class="comment">//只有一个节点的情况</span></span><br><span class="line">deleteCircularLinkedListHead(head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!= index) &#123;<span class="comment">//说明没有找到这个节点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败=============&gt;没有这个元素\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* temp = p-&gt;next;<span class="comment">//temp表示的就是需要删除的节点</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> == index &amp;&amp; head-&gt;next == temp-&gt;next) &#123;<span class="comment">//说明是尾删除</span></span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = temp-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEleCircularLinkedListByIndex</span><span class="params">(cLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取元素失败===========&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= index &amp;&amp; p-&gt;next != head-&gt;next) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != index+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构中的单向循环链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://i-fire.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>今日份开心</title>
    <link href="https://i-fire.top/post/todayHappiness.html"/>
    <id>https://i-fire.top/post/todayHappiness.html</id>
    <published>2021-02-21T11:39:53.000Z</published>
    <updated>2021-02-21T11:46:11.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天的快乐"><a href="#今天的快乐" class="headerlink" title="今天的快乐"></a>今天的快乐</h1><p>今天小学生开学了，我去了以前上小学的地方，门口的小店竟然有冷饮卖！开森！！</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210221193807.jpg"></p>]]></content>
    
    
    <summary type="html">开森</summary>
    
    
    
    <category term="心情随笔" scheme="https://i-fire.top/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>静态链表</title>
    <link href="https://i-fire.top/post/staticLinkedList.html"/>
    <id>https://i-fire.top/post/staticLinkedList.html</id>
    <published>2021-02-21T11:26:43.000Z</published>
    <updated>2021-02-21T11:28:54.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h4 id="顺序表和链表的优缺点"><a href="#顺序表和链表的优缺点" class="headerlink" title="顺序表和链表的优缺点"></a>顺序表和链表的优缺点</h4><p>从之前写的动态数组（线性表的顺序存储方式）和单链表（线性表的链式存储方式）代码来说，二者都有一些优缺点，对于动态数组，<br>查询和写入（非存储）数据很快，但是当存储数据时，需要不停地移动元素，如果碰上动态数组满了的情况，那么还需要对动态数组进行扩容，对于存储来说，效率很低。对于链表来说，每次查询或者写入一个元素的时候，需要从头遍历整个链表来找到需要写入数据的节点，效率也不是很高，对于插入数据来说，只要找到当前节点的前驱，然后修改前驱节点的指针的指向即可，相比动态数组插入元素而言效率要高。有没有一种数据结构可以克服这些缺点同时继承他们的优点？？那就是<strong>静态链表</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。<br>使用静态链表存储数据，数据全部在数组中（类似动态数组），但是存储的位置是随机的，数据之间的链式关系（一个接一个）通过一个整型变量（称之为<strong>游标，类似单链表中每个节点的指针</strong>）</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用静态链表存储数组{1,2,3}<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092258.png"></p><p>接着，在将数据存放到数组中时，给各个数据元素配备一个整形变量，此变量用于指明各个元素的直接后继元素所在数组中的位置下标，如图 2 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220092407.png"></p><p>通常，静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。<br>图 2 中，从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。<br>类似图 2 这样，通过 “数组+游标” 的方式存储具有线性关系数据的存储结构就是静态链表。</p><h3 id="静态链表中的节点"><a href="#静态链表中的节点" class="headerlink" title="静态链表中的节点"></a>静态链表中的节点</h3><p>静态链表中的节点也包含两个部分，但是和单链表不同的就是单链表节点中的指针域变成了静态链表中的<strong>游标</strong>，游标不是一个指针，它记录的是当前节点的下一个节点在数组中的位置（也就是数组元素的下标）</p><ul><li>数据域：存储数据元素</li><li>游标：其实就是数组下标，表示直接后继元素所在数组中的位置；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tydef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备用链表"><a href="#备用链表" class="headerlink" title="备用链表"></a>备用链表</h3><p>可以看到，图2中的数组不是很完整：数据中有6个位置，但是实际上值存储了3个元素，空出来了3个位置，这三个位置我们也是可以利用的。在静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称之为备用链表。<br>备用链表的作用是回收数组中未使用或者之前使用但是目前没有使用的存储空间，以待后期使用，也就是说，静态链表使用数组申请的物理空间，存在两个链表，一个连接着数据，另外一条连接着数组中还未使用过的空间</p><blockquote><p>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p></blockquote><p>在静态链表中使用备用链表的好处就是可以清楚地知道数组中是否有空闲位置，一遍数据链表添加数据的时候使用。如果静态链表中数组下标为0的位置上存有数据，则证明数组满了<br>例如，使用静态链表存储 <code>&#123;1,2,3&#125;</code>，假设使用长度为 6 的数组 a，则存储状态可能如图 3 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220093947.png"></p><h3 id="静态链表的实现"><a href="#静态链表的实现" class="headerlink" title="静态链表的实现"></a>静态链表的实现</h3><p>假设静态链表（长度为6）存储{1,2,3}，需要经过如下几个阶段<br>当链表没有进行初始化的时候，数组中的所有的位置都处于空闲转态，因此都应该被连接都备用链表上<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100716.png"></p><blockquote><p>备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表</p></blockquote><p>因此，在图 4 的基础上，向静态链表中添加元素 1 的过程如图 5 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220100919.png"></p><p>在图 5 的基础上，添加元素 2 的过程如图 6 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101301.png"></p><p>在图 6 的基础上，继续添加元素 3 ，过程如图 7 所示：<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210220101448.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typename int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  next;</span><br><span class="line">    <span class="keyword">typename</span> context;</span><br><span class="line">&#125;Node,List[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List <span class="built_in">list</span>;</span><br><span class="line">    InitStatic(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">int</span> h,i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h);</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>].next = h;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f);</span><br><span class="line">        <span class="built_in">list</span>[i].context = f;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>[h<span class="number">-1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>[MAX - <span class="number">1</span>].next = <span class="number">1</span>;<span class="comment">//为已用链表的头结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度为：%d\n&quot;</span>,get_Length(<span class="built_in">list</span>));</span><br><span class="line">    <span class="comment">/*Insert(list,1,5);</span></span><br><span class="line"><span class="comment">    printf(&quot;长度为：%d\n&quot;,get_Length(list));*/</span></span><br><span class="line">    print(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitStatic</span><span class="params">(Node *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        l[i].context = <span class="number">0</span>;</span><br><span class="line">        l[i].next = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l[MAX - <span class="number">1</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLode</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">list</span>[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">if</span>(m) &#123;</span><br><span class="line">        <span class="built_in">list</span>[<span class="number">0</span>].next = <span class="built_in">list</span>[m].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得有效长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_Length</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>,i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Node *l,<span class="keyword">int</span> i,<span class="keyword">typename</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = getLode(l),j = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; get_Length(l) + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入错误！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = m;</span><br><span class="line">        l[m].next = <span class="number">1</span>;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;j &lt; i - <span class="number">1</span>;j++)  k = l[k].next;</span><br><span class="line">        l[m].context = x;</span><br><span class="line">        l[m].next = l[k].next;</span><br><span class="line">        l[k].next = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Node *l,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>,m = <span class="number">1</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        f = l[MAX - <span class="number">1</span>].next;</span><br><span class="line">        l[MAX - <span class="number">1</span>].next = l[f].next;</span><br><span class="line">        l[f].next = l[<span class="number">0</span>].next;</span><br><span class="line">        l[<span class="number">0</span>].next = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;j &lt; k - <span class="number">1</span>;j++) m = l[m].next;</span><br><span class="line">    k = l[m].next;</span><br><span class="line">    l[m].next = l[k].next;</span><br><span class="line">    l[k].next = l[<span class="number">0</span>].next;</span><br><span class="line">    l[<span class="number">0</span>].next = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据的展示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">list</span>[MAX - <span class="number">1</span>].next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">list</span>[i].next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">        i = <span class="built_in">list</span>[i].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据为：%d\n&quot;</span>,<span class="built_in">list</span>[i].context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，静态链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="静态链表" scheme="https://i-fire.top/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（）二</title>
    <link href="https://i-fire.top/post/linearStructureTwo.html"/>
    <id>https://i-fire.top/post/linearStructureTwo.html</id>
    <published>2021-02-19T09:28:03.000Z</published>
    <updated>2021-02-19T09:29:06.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的缺点<br>借助指针等手段来表示数据元素 a<sub>i</sub> 和直接后继元素 a<sub>i+1</sub> 之间的关系，a<sub>i</sub> 不仅存储本身的信息，还存储指向后继的指针。<br>数据元素（数据域）和指向后继的指针（指针域）合起来称为一个结点，n 个结点链接成一个链表即为线性表的链式存储结构。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>数据域：存储真实的数据元素</li><li>指针域：下一个节点的地址（指针）</li></ul><pre class="mermaid">graph TDA[节点] --> B[数据域]A[节点] --> C[指针域]</pre><h3 id="首元节点"><a href="#首元节点" class="headerlink" title="首元节点"></a>首元节点</h3><p>链表中第一个存放数据的元素所在的结点，它是头结点后边的第一个结点。</p><h3 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h3><p>一般把<strong>链表</strong>中的<strong>第一个结</strong>点称为 <strong>头指针</strong>，其<strong>存储</strong>链表的<strong>第一个数据元素</strong>，在有头节点的情况下头指针指向的应该是指向的是头节点，无头节点的情况下头指针指向的是首元节点</p><h3 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h3><p>为了能更加方便地对链表进行操作，会在<strong>单链表的第一个结点（即头指针）前</strong>附<strong>设一个结点</strong>，称为 <strong>头结点</strong>，头节点中可以存储一些附加数据，例如：当前线性表的长度等等,在处理某些问题时，给链表添加头结点会使问题变得简单。</p><pre class="mermaid">graph LRO[头指针]-->A[头节点]A[头节点]-->B[线性表的首元节点]A[头节点]-->C[线性表的长度]A[头节点]-->D[线性表的尾指针]A[头节点]-->M[还可以再加....]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><pre class="mermaid">graph LRO[头指针]-->B[线性表的首元节点]B[线性表的首元节点]-->E[数据域]B[线性表的首元节点]-->F[指针域]F[指针域]-->G[线性表节点]G[线性表节点]-->H[数据域]G[线性表节点]-->I[指针域]I[指针域]-->J[线性表节点]J[线性表节点]-->K[数据域]J[线性表节点]-->L[指针域]</pre><p><strong>头结点和头指针的区别</strong>：头指针是一个指针，头指针指向链表的头结点或者首元结点；头结点是一个实际存在的结点，它包含有数据域和指针域。两者在程序中的直接体现就是：头指针只声明而没有分配存储空间，头结点进行了声明并分配了一个结点的实际物理内存。单链表中可以没有头结点，但是不能没有头指针！</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>在单链表中，对于每个结点来说，除了存储本身的信息外，还需要存放一个指向其后继的指针。逻辑位置相<br>邻但物理位置不相邻的数据元素用单链表链接<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219085612.png"></p><ul><li>对于存取操作：而对于单链表结构，假设需要获取第 i 个元素，则必须从第一个结点开始依次进行遍历，直到达到第 i 个结点。因此，对于单链表结构而言，其数据元素读取的<strong>时间复杂度</strong>为<strong>O<sub>(n)</sub></strong></li><li>对于<strong>插入和删除</strong>操作：而对单链表结构来说，对其任意一个位置进行增删操作，其<strong>时间复杂度</strong>为 O<sub>(n)</sub>，<strong>因为</strong>需要先进行<strong>遍历找到目标元素</strong>，对头指针的增删操作其<strong>时间复杂度</strong>为O<sub>(1)</sub></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义单链表节点的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//节点中的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singleLinkedListNode</span>* <span class="title">next</span>;</span><span class="comment">//节点中的指针域</span></span><br><span class="line">&#125; sLLNode;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span></span>;<span class="comment">//初始化单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//单链表头插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//遍历输出单链表中所有的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span></span>;<span class="comment">//销毁单链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span></span>;<span class="comment">//获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在单链表的尾部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//获取单链表中第index个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在第index个位置前添加一个元素，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//删除第index位置上的元素，同时将它返回出去，index从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span></span>;<span class="comment">//根据数据查找对应的index，没有就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">sLLNode* singleLinkedList = initSingleLinkedList();</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">1</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">11</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListHead(singleLinkedList, <span class="number">122</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addEleInSingleLinkedList(singleLinkedList, <span class="number">100</span>);</span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">1</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是%d\n&quot;</span>, <span class="number">2</span>, getSingleLinkedListEleByIndex(singleLinkedList, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addSingleLinkedListEleByIndex(singleLinkedList, <span class="number">20</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1000所在的第一个节点的index是%d\n&quot;</span>,findEleByIndex(singleLinkedList,<span class="number">1000</span>));</span><br><span class="line">deleteSingleLinkedListByIndex(singleLinkedList, <span class="number">2</span>);</span><br><span class="line">outSingleLinkedList(singleLinkedList);</span><br><span class="line">destorySingleLinkedList(&amp;singleLinkedList);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的长度是%d&quot;</span>, getSingleLinkedListLength(singleLinkedList));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sLLNode* <span class="title">initSingleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造出头指针</span></span><br><span class="line">sLLNode* head = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化单链表失败，失败原因===================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListHead</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表头插入失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表的头插入失败，失败原因==================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"><span class="comment">//用临时变量保存原来的头节点后面一个节点的地址</span></span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outSingleLinkedList</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;遍历单链表失败，失败原因=======================&gt;参数不合法\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表中第%d个元素是====================&gt;%d\n&quot;</span>, i, temp-&gt;data);</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destorySingleLinkedList</span><span class="params">(sLLNode** head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !(*head)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁单链表失败======================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = *head;</span><br><span class="line">sLLNode* temp;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">temp = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = temp;</span><br><span class="line">&#125;</span><br><span class="line">*head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListLength</span><span class="params">(sLLNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表长度失败====================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (temp)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEleInSingleLinkedList</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败============================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next) &#123;<span class="comment">//当当前节点的下一个节点为空时，说明已经抵达单链表的最后一个节点！</span></span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* node = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (!node) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表尾部插入元素失败===================&gt;空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//一定一定要将最后一个节点的next指针置为NULL！！！</span></span><br><span class="line">temp-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取单链表中数组失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index &amp;&amp; temp)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line"><span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSingleLinkedListEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在单链表指定位置添加元素失败===========================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sLLNode* p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) &#123;<span class="comment">//判断是不是头添加,需要将指针p指向头指针并非是头节点，这样才能找到头添加时需要的前驱</span></span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; p) &#123;<span class="comment">//需要找到index位置的节点的前驱所以是p-&gt;next</span></span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">sLLNode* temp = (sLLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sLLNode));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">temp-&gt;data = e;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">sLLNode* currentNode = p-&gt;next;<span class="comment">//currentNode中保存的才是对应单链表中第index个节点</span></span><br><span class="line">temp-&gt;next = currentNode;</span><br><span class="line">p-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;空间不足！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单链表指定位置添加元素失败！==========================&gt;index位置的节点不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteSingleLinkedListByIndex</span><span class="params">(sLLNode* head, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除单链表元素失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span> &amp;&amp; head-&gt;next) &#123;<span class="comment">//判断是不是头删除</span></span><br><span class="line">temp = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; index - <span class="number">1</span> &amp;&amp; temp) &#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp) &#123;</span><br><span class="line">sLLNode* currentNode = temp-&gt;next;</span><br><span class="line">temp-&gt;next = currentNode-&gt;next;</span><br><span class="line">data = currentNode-&gt;data;</span><br><span class="line"><span class="built_in">free</span>(currentNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据index删除元素失败========================&gt;index对应的元素不存在\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findEleByIndex</span><span class="params">(sLLNode* head, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据值查找index失败==================&gt;参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">sLLNode* temp = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data == e) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据结构，单链表</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性结构（一）</title>
    <link href="https://i-fire.top/post/linearStructureOne.html"/>
    <id>https://i-fire.top/post/linearStructureOne.html</id>
    <published>2021-02-19T09:23:57.000Z</published>
    <updated>2021-02-19T09:27:00.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性结构（一）"><a href="#线性结构（一）" class="headerlink" title="线性结构（一）"></a>线性结构（一）</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>含有n个相同元素的数据元素的有限序列称为线性表<br>一般可以表示为：L(a<sub>1</sub>,a<sub>2</sub>,…….,a<sub>n-1</sub>,a<sub>n</sub>)<strong>注意：</strong>a<sub>i-1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>n</sub> 的直接后继元素。线性表中数据元素的个数 n（n＞0）为线性表的长度。当 n＝0 时称线性表为空表。</p><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><pre class="mermaid">graph TDA[线性表] --> B[顺序存储结构]A[线性表] --> C[链式存储结构]B[顺序存储结构] --> D[动态数组]C[链式存储结构] --> E[单链表]C[链式存储结构] --> F[静态链表]C[链式存储结构] --> H[循环链表]C[链式存储结构] --> I[双向链表]</pre><h3 id="顺序存储结构-动态数组"><a href="#顺序存储结构-动态数组" class="headerlink" title="顺序存储结构(动态数组)"></a>顺序存储结构(动态数组)</h3><p>（又称顺序表）是一种随机存取的结构，逻辑关系上相邻的元素物理位置上也相邻。数组是表<br>示顺序存储结构最简单的一个方式。如图 2-1 所示，只要确定了存储线性表的起始位置，线性表中任一数据元素<br>都可随机存取。<br><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210219082748.png"></p><p><strong>顺序存储结构的特点</strong></p><p>优点：</p><p>①它是一个记录型的结构。数据元素的存储位置可用数组的下标值（即相对于线性表的起始位置的值）来表</p><p>示；</p><p>②在顺序存储结构中，线性表的某些操作容易实现，如求表长的操作；</p><p>缺点：</p><p>①在做插入或删除操作时，需移动大量元素；</p><p>②在给长度变化较大的线性表预先分配空间时，必须按最大空间分配，易造成了空间的浪费；</p><p>③表的容量难以扩充</p>]]></content>
    
    
    <summary type="html">数据结构</summary>
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线性结构" scheme="https://i-fire.top/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器时区问题</title>
    <link href="https://i-fire.top/post/chrom.html"/>
    <id>https://i-fire.top/post/chrom.html</id>
    <published>2021-02-01T01:47:17.000Z</published>
    <updated>2021-02-01T01:56:05.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决谷歌浏览器时间不同步问题"><a href="#解决谷歌浏览器时间不同步问题" class="headerlink" title="解决谷歌浏览器时间不同步问题"></a>解决谷歌浏览器时间不同步问题</h1><p>昨天站长在谷歌浏览器测试项目的时候奇怪的发现，前端js同一个时间戳解析出来的时间与我的本地时区相差16个小时（之前在项目中就有疑惑，后台发现用户总是喜欢在凌晨注册，没有引起好奇），我是在东八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>+08:00），但是时间戳格式化出来的却是西八区（<a href="https://baike.baidu.com/item/UTC">UTC</a>/<a href="https://baike.baidu.com/item/GMT/6026868">GMT</a>-08:00），我一直以为是js没有设置时区问题（一般来说都会按照本地时区对时间戳进行格式化，基本不会让开发者自己设置），于是我各种百度，找到的解决办法也是五花八门（到此为止我还没有意识到是谷歌浏览器自己出问题，并非是我的电脑问题），然后我才想起来同一个时间戳放到不同的浏览器上去解析一下，验证是不是我的时区问题。嘿！edge，火狐都没有问题，就是谷歌出问题，最后在一个贴吧老哥那里找到的解决办法——-》修改电脑时区</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul><li><p>先将自己的时区随便设置一个，这里要先关掉自动设置时区，然后才能自己设置时区</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094157.png"></p></li><li><p>接着再将本地的时区改回来，我这里是东八区，于是我在改回东八区，至此问题解决</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210201094338.png"></p></li></ul>]]></content>
    
    
    <summary type="html">谷歌浏览器格式化时间与本地时区相差16小时</summary>
    
    
    
    <category term="小技巧" scheme="https://i-fire.top/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="chrome" scheme="https://i-fire.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>我爱签到网使用教程</title>
    <link href="https://i-fire.top/post/52sign.html"/>
    <id>https://i-fire.top/post/52sign.html</id>
    <published>2021-01-17T02:43:30.000Z</published>
    <updated>2021-01-17T03:16:11.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我爱签到网使用教程"><a href="#我爱签到网使用教程" class="headerlink" title="我爱签到网使用教程"></a>我爱签到网使用教程</h1><h3 id="平台介绍"><a href="#平台介绍" class="headerlink" title="平台介绍"></a>平台介绍</h3><p>一个集成了各大平台打卡签到功能的系统，基于springboot和layui开发，大部分功能完全免费</p><h3 id="目前已经有的功能"><a href="#目前已经有的功能" class="headerlink" title="目前已经有的功能"></a>目前已经有的功能</h3><ul><li>学习通签到<ul><li>普通签到</li><li>位置签到</li><li>手势签到</li></ul></li><li>网易云打卡<ul><li>云贝打卡</li><li>每日听歌300首</li></ul></li></ul><p><strong>PS：只要保持各大平台的密码正确，完全可以实现自动化签到，彻底解放双手</strong></p><p><strong>PS：后续会添加更多自动化功能</strong></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>打卡我爱签到网网址：<a href="https://52sign.top/">https://52sign.top/</a></p></li><li><p>点击注册用户，点击这两处都行</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100006.png"></p></li><li><p>按照要求输入相应的信息即可，然后点击注册</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117100213.png"></p></li><li><p>注册成功后会收到一封激活邮箱的邮件，只有先激活邮箱，才能登陆网站</p></li><li><p>然后登陆到网站里面，看到当前页面说明注册成功</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102141.png"></p></li><li><p>登陆成功后即可开始使用（以学习通签到为例）</p><ul><li><p>首先需要添加一个学习通账号</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102605.png"></p></li></ul></li><li><p>添加完毕后获取学习通账户的所有课程</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117102839.png"></p><p>选择刚才添加的学习通账号，然后获取到账号中的所有的课程后</p><ul><li><p>为课程添加签到任务</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103156.png"></p></li><li><p>查看签到所有的签到任务</p><p><img src="C:\Users\15061\AppData\Roaming\Typora\typora-user-images\image-20210117103344648.png"></p></li><li><p>查看学习通签到日志</p><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20210117103415.png"></p></li></ul><p><strong>注意：数据库中的数据没10分钟才会同步一次，有时候日志里面没有数据不代表没签上，具体以学习通是否签到为准</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>至此演示了学习通签到任务的添加流程，网易云也是大同小异，请自己研究一下！！</p>]]></content>
    
    
    <summary type="html">全自动打卡，彻底解放你的双手，让您专注于手头的任务上</summary>
    
    
    
    <category term="项目" scheme="https://i-fire.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://i-fire.top/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="我爱签到网" scheme="https://i-fire.top/tags/%E6%88%91%E7%88%B1%E7%AD%BE%E5%88%B0%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>警醒</title>
    <link href="https://i-fire.top/post/warn.html"/>
    <id>https://i-fire.top/post/warn.html</id>
    <published>2021-01-15T00:47:12.000Z</published>
    <updated>2021-01-15T00:55:18.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="警戒"><a href="#警戒" class="headerlink" title="警戒"></a>警戒</h1><p>今天是2021年1月15号，谨以此文章记录一年前的今天我在某重大战役中的胜利</p><p><strong>凡事必须三思而后行</strong></p>]]></content>
    
    
    <summary type="html">警戒</summary>
    
    
    
    <category term="大事记" scheme="https://i-fire.top/categories/%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
    
    
    <category term="生活" scheme="https://i-fire.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>选择排序 SelectSort</title>
    <link href="https://i-fire.top/post/xuanze.html"/>
    <id>https://i-fire.top/post/xuanze.html</id>
    <published>2020-12-26T10:46:22.000Z</published>
    <updated>2020-12-26T10:51:22.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从头到尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下来的元素中继续这种选择和交换方式，最终得到一个有序序列</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20201226182244.gif" alt="选择排序动画演示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span></span>;<span class="comment">//嵌套for循环进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span></span>;<span class="comment">//一个递归加上一个for循环进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortTwo(<span class="number">15</span>,&amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//数组长度小于2，不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> iminpos=<span class="number">0</span>;<span class="comment">//记录每趟循环中最小值的下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">iminpos = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj = i+<span class="number">1</span>; jj&lt;length; jj++) &#123;<span class="comment">//下标从jj开始的元素中的最小值，将最小值的下标赋值给 iminpos</span></span><br><span class="line"><span class="keyword">if</span>(arr[jj]&lt;arr[iminpos]) &#123;</span><br><span class="line">iminpos=jj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iminpos!=i) &#123;<span class="comment">//对找出来的最小值  arr[iminpos]和 arr[i]交换顺序 </span></span><br><span class="line"><span class="keyword">int</span> temp = arr[iminpos];</span><br><span class="line">arr[iminpos] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> length,<span class="keyword">int</span> *arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(length&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//数组长度小于2，不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> iminpos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> jj =<span class="number">1</span>; jj&lt;length; jj++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[jj]&lt;arr[iminpos]) &#123;<span class="comment">//下标从jj开始的元素中的最小值，将最小值的下标赋值给 iminpos</span></span><br><span class="line">iminpos=jj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iminpos!=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[iminpos];<span class="comment">//将找到的最小值放入传入的数组的第一个位置，由于每一次的递归都会将数组的指针向后移动一个，所以arr[0]的位置是在不停的不变化 </span></span><br><span class="line">arr[iminpos]=temp;</span><br><span class="line">&#125;</span><br><span class="line">sortTwo(--length,arr+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">选择排序，算法</summary>
    
    
    
    <category term="算法" scheme="https://i-fire.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://i-fire.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://i-fire.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序 BubbleSort</title>
    <link href="https://i-fire.top/post/maopao.html"/>
    <id>https://i-fire.top/post/maopao.html</id>
    <published>2020-11-20T08:28:37.000Z</published>
    <updated>2020-11-20T08:32:42.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在排序的的过程中，会依次的对相邻的两个元素进行比较，如果左边的元素大于右边的元素，那么就会将这两个元素进行交换，类似气泡一样左右浮动</p><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://cdn.jsdelivr.net/gh/i-fire/blog-pic@main/usr/20201120153054.gif" alt="冒泡排序图示"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>通过上面的图示，我们可以看到每次移动元素都是从左边第一个依次的向后进行比较，这样我们就以通过一个for循环实现，此外，每次走遍一整个的比较循环，会将当前需要排序的数组中的最大值排在按序排在数组的尾部，所以我们还需要一个for循环来控制有多少个找出数组剩余元素最大值的循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用两个for循环实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortOne(&amp;arr[<span class="number">0</span>],<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;<span class="comment">//对排序后的数组进行输出，看看是否真的排序成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;<span class="comment">//控制内层找出数组剩余元素最大值的循环的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;<span class="comment">//每次都会将数组的长度减一，因为一个找出数组剩余元素最大值的循环就会找出当前数组中的最大值，并按序放置在数组的尾部，每次需要比较的都是剩下来的没有比较的数组</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123; <span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过两个for循环的方法，还可以衍生出一个for循环+一个递归实现冒泡排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用一个for循环和一个递归实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">15</span>]= &#123;<span class="number">12</span>,<span class="number">3123</span>,<span class="number">434</span>,<span class="number">22</span>,<span class="number">7</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6799</span>,<span class="number">89</span>,<span class="number">20</span>,<span class="number">12</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line">sortTwo(&amp;arr[<span class="number">0</span>],<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) &#123;<span class="comment">//对排序后的数组进行输出，看看是否真的排序成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;<span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>]=temp; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortTwo(arr,--count);<span class="comment">//将原来控制找出数组剩余元素最大值的循环次数的外层for循环替换成了递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>上述的两种实现方式都存在一个问题，就是在排序的过程中需要排序的数组就已经因为原数组元素的顺序问题已经达到从小到大的排序的目的，但是循环还没有停止，这样就会造成不必要的内存开销，那么我们可以对上述的两种方式进行优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;<span class="comment">//使用两个for循环实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count,<span class="keyword">int</span> n)</span></span>;<span class="comment">//使用一个for循环和一个递归实现冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">71</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">//定义需要排序的数组</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">//用来记录循环的次数</span></span><br><span class="line">sortOne(&amp;arr[<span class="number">0</span>],<span class="number">9</span>);</span><br><span class="line">sortTwo(&amp;arr[<span class="number">0</span>],<span class="number">9</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的第%d个元素是%d\n&quot;</span>,(i+<span class="number">1</span>),arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortOne</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">//用来记录循环的次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> isSwap=<span class="number">0</span>;<span class="comment">//用来记录内层循环是否发生了元素之间的交换，0：没有发生交换，1：发生了交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123; <span class="comment">//如果后一个的值小于前一个值，那么就交换顺序</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">isSwap=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isSwap==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//如果没有发生元素的交换，那么说明排序已经完成，那么接下来直接结束循环就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortTwo</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">unsigned</span> <span class="keyword">int</span> count,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isSwap=<span class="number">0</span>;<span class="comment">//用来记录内层循环是否发生了元素之间的交换，0：没有发生交换，1：发生了交换</span></span><br><span class="line"><span class="keyword">if</span>(count&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//元素小于两个的数组不需要排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[i];</span><br><span class="line">arr[i]=arr[i+<span class="number">1</span>];</span><br><span class="line">arr[i+<span class="number">1</span>]=temp;</span><br><span class="line">isSwap=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isSwap==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;循环了%d次\n&quot;</span>,n);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//如果没有发生元素的交换，那么说明排序已经完成，那么接下来直接结束循环就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">sortTwo(arr,--count,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用一个变量来记录在排序还没有停止，但是实际上已经将数组排序完毕的情况，这样可以大大的较少不必要的开销</p>]]></content>
    
    
    <summary type="html">冒泡排序，算法</summary>
    
    
    
    <category term="算法" scheme="https://i-fire.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://i-fire.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="冒泡排序" scheme="https://i-fire.top/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>DynamicArray 动态数组</title>
    <link href="https://i-fire.top/post/dynamicarray.html"/>
    <id>https://i-fire.top/post/dynamicarray.html</id>
    <published>2020-11-14T11:03:09.000Z</published>
    <updated>2021-02-19T09:27:13.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>在c语言中我们都听过数组，创建一个数组也很简单，例如我们创建一个简单的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>]=&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//这样我们就创建好了一个数组，并且对其进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的数组创建好后，数组的大小就会被固定下来，当我们想要添加第三个元素的时候，那么就无法添加成功，怎么解决？？？</p><p>我们可以使用动态数组这样的线性结构来解决数组不能够增大容量的问题</p><h2 id="动态数组-1"><a href="#动态数组-1" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>动态数组，顾名思义就是能够动态的添加元素（从堆内存动态的分配存储空间），不会存在容量满了这一说法，只要我想添加元素，那么就可以添加元素</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>动态数组的实现我们可以依托c语言提供的普通数组实现，定义一个结构体变量，结构体变量中有三个元素</p><ul><li><p>int * P：用来保存一个数组，数组中存储的是用户自定义的数据</p></li><li><p>unsigned int Container：数组的容量</p></li><li><p>unsigned int I：数组已经存储元素的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> * P;<span class="comment">//数组的头指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Container;<span class="comment">//数组的容量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> I;<span class="comment">//数组已经存储元素的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="动态数组常用的方法"><a href="#动态数组常用的方法" class="headerlink" title="动态数组常用的方法"></a>动态数组常用的方法</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">//定义结构体，用来保存动态数组的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> length;<span class="comment">//动态数组的总容量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> currentContainer;<span class="comment">//动态数组当前已经存放了多少个元素</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//保存静态数组的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态数组的常用操作方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">// 初始化动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向动态数组中插入一个元素（尾插入）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expandDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//动态数组进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDynamicArrayEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//获取动态数组中的一个元素，index从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//销毁动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//判断动态数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addEleByIndex</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span></span>;<span class="comment">//向数组中的任意位置添加一个元素,index从0开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInHead</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span></span>;<span class="comment">//在动态数组头部添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//清空动态数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(struct dynamicArray* dynamicArray)</span></span>;<span class="comment">//遍历输出数组所有的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;<span class="comment">//删除动态数组中的一个元素,下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个没有初始化的动态数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dynamicArray</span> <span class="title">array</span>;</span></span><br><span class="line"><span class="comment">//对动态数组进行初始化</span></span><br><span class="line">initDynamicArray(&amp;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">3</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">4</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">5</span>);</span><br><span class="line">add(&amp;<span class="built_in">array</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">32</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">33</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">31</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">3</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">23</span>);</span><br><span class="line">addInHead(&amp;<span class="built_in">array</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line">deleteEle(&amp;<span class="built_in">array</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">addEleByIndex(&amp;<span class="built_in">array</span>,<span class="number">2</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">out(&amp;<span class="built_in">array</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断传递的是否是null</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化方法中传递的参数不合法\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;length = <span class="number">5</span>;<span class="comment">//初始化数据的容量</span></span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;<span class="comment">//初始化时没有任何的元素</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">5</span>);<span class="comment">//初始化时分配5个存储空间</span></span><br><span class="line"><span class="comment">//判断是否成功申请到空间</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化失败,失败原因=============&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;p = p;<span class="comment">//将动态数组中的静态数组指针指向初始化的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;向动态数组中添加元素错误，失败原因==================&gt;动态数组地址错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断动态数组中是否满了，如果满了就扩容</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;length == dynamicArray-&gt;currentContainer &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="comment">//扩容失败，直接返回</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;添加元素失败，失败原因====================&gt;空间不足，无法扩容\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">(dynamicArray-&gt;p)[dynamicArray-&gt;currentContainer] = e;</span><br><span class="line"><span class="comment">//这里的currentContainer有两个作用，第一个就是记录数组中已经存放了多少个元素，其次就是数组中已有元素中的最后一个元素的下一个元素的下标</span></span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;<span class="comment">//当前数组的长度+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expandDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (dynamicArray-&gt;length + <span class="number">5</span>));<span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;动态数组扩容失败！原因=======================&gt;内存空间不足\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;length = dynamicArray-&gt;length + <span class="number">5</span>;<span class="comment">//动态数组的长度+5</span></span><br><span class="line"><span class="comment">//将原来的动态数组中的数据拷贝到新的数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynamicArray-&gt;currentContainer; i++) &#123;</span><br><span class="line">p[i] = (dynamicArray-&gt;p)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(dynamicArray-&gt;p);<span class="comment">//释放原来的空间</span></span><br><span class="line">dynamicArray-&gt;p = p;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDynamicArrayEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span> || index &gt;= dynamicArray-&gt;currentContainer) &#123;<span class="comment">//传递的index越界也是不行的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取元素失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (dynamicArray-&gt;p)[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destoryDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;销毁动态数组失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组空间</span></span><br><span class="line"><span class="built_in">free</span>(dynamicArray-&gt;p);</span><br><span class="line"><span class="comment">//数组的总长度和已经存放的元素的长度全部置为0</span></span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;</span><br><span class="line">dynamicArray-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;判断数组是否为空失败，原因================&gt;传递参数错误\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addEleByIndex</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span> || index&lt;<span class="number">0</span> || index&gt;dynamicArray-&gt;length) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据下标添加元素失败，失败原因===============&gt;参数不合法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == dynamicArray-&gt;length &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;根据下标添加元素失败，失败原因===============&gt;数组扩容失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是不是尾添加，是尾添加直接调用尾添加方法</span></span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == index) &#123;</span><br><span class="line">add(dynamicArray, e);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是不是头添加，是头添加直接调用头添加方法</span></span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">addInHead(dynamicArray, e);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dynamicArray-&gt;currentContainer; i &gt; index; i--) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">(dynamicArray-&gt;p)[index] = e;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addInHead</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头添加元素失败，失败原因===============&gt;参数不合法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dynamicArray-&gt;currentContainer == dynamicArray-&gt;length &amp;&amp; FALSE == expandDynamicArray(dynamicArray)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;头添加失败，失败原因=============&gt;动态数组扩容失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dynamicArray-&gt;currentContainer; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">(dynamicArray-&gt;p)[<span class="number">0</span>] = e;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearDynamicArray</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line">dynamicArray-&gt;currentContainer = <span class="number">0</span>;<span class="comment">//直接将当前数组置为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(struct dynamicArray* dynamicArray)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynamicArray-&gt;currentContainer; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;动态数组第%d个位置的元素是============&gt;%d\n&quot;</span>, i, (dynamicArray-&gt;p)[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEle</span><span class="params">(struct dynamicArray* dynamicArray, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= dynamicArray-&gt;currentContainer || dynamicArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除动态数组中的元素失败，失败原因====================&gt;参数错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; dynamicArray-&gt;currentContainer - <span class="number">1</span>; i++) &#123;</span><br><span class="line">(dynamicArray-&gt;p)[i] = (dynamicArray-&gt;p)[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dynamicArray-&gt;currentContainer = dynamicArray-&gt;currentContainer - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>当我们定义了文章开头的结构的时候，我们就是将这个结构体作为动态数组在使用</p><h4 id="扩容机制实现"><a href="#扩容机制实现" class="headerlink" title="扩容机制实现"></a>扩容机制实现</h4><p>当结构体中Container和I变量两个值相等的时候，那么当前结构体中p指针指向的数组就存储满了，那么就会调用malloc方法申请一块新的内存空间（每一个扩容都是在原来的容量上加10），并且使用for循环将原来p指针指向的数组中的数据拷贝到新的数组中，同时修改p指针的指向并且释放原来p指针指向的地址的内存空间</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>头添加时循环条件问题：int i = dynamicArray-&gt;currentContainer; i &gt; 0;i–，</p><ul><li><p>为啥int i = dynamicArray-&gt;currentContainer不是int i = dynamicArray-&gt;currentContainer-1？因为头添加的时候</p><p>数组需要将第一个元素空出来整体元素向后移动一个单位，int i = dynamicArray-&gt;currentContainer中的i就是移动过后最后一个元素的下标，如果是int i = dynamicArray-&gt;currentContainer-1那么就会丢失移动前的最后一个元素！！</p></li></ul></li><li><p>中间添加循环条件问题（既不是头添加，也不是尾添加）：int i = dynamicArray-&gt;currentContainer为什么不是int i = dynamicArray-&gt;currentContainer-1，因为int i = dynamicArray-&gt;currentContainer-1表示的是动态数组中已经添加的最后一个元素的下标，移动完毕后，int i = dynamicArray-&gt;currentContainer-1那么就会丢失移动前的最后一个元素！！</p></li></ul><h3 id="动态数组的优缺点"><a href="#动态数组的优缺点" class="headerlink" title="动态数组的优缺点"></a>动态数组的优缺点</h3><ul><li><p>优点</p><ul><li>能够动态的扩容，不存在把动态数组存储满了这一说法</li><li>依赖c语言中静态数组实现，在读写数据的时候根据下标进行查询，读写速度快</li></ul></li><li><p>缺点</p><ul><li>由于采用静态数组进行数据存储，当删除中间的元素的时候，会发生重新申请空间或者for循环移动数组次数太多的问，对于删除操作来说很慢</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态数组&quot;&gt;&lt;a href=&quot;#动态数组&quot; class=&quot;headerlink&quot; title=&quot;动态数组&quot;&gt;&lt;/a&gt;动态数组&lt;/h1&gt;&lt;p&gt;在c语言中我们都听过数组，创建一个数组也很简单，例如我们创建一个简单的数组&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态数组" scheme="https://i-fire.top/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介</title>
    <link href="https://i-fire.top/post/datastructure.html"/>
    <id>https://i-fire.top/post/datastructure.html</id>
    <published>2020-11-14T11:03:08.000Z</published>
    <updated>2020-11-15T09:03:38.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/9663235">逻辑结构</a>和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构</p><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782">存储结构</a></p><p>数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义。上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程</p><h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>指反映数据<a href="https://baike.baidu.com/item/%E5%85%83%E7%B4%A0">元素</a>之间的逻辑关系的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>，其中的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB">逻辑关系</a>是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括</p><p>1.集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系</p><p>2.线性结构：数据结构中的元素存在一对一的相互关系</p><p>3.<a href="https://baike.baidu.com/item/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84">树形结构</a>：数据结构中的元素存在一对多的相互关系</p><p>4.<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84">图形结构</a>：数据结构中的元素存在多对多的相互关系</p><h3 id="数据的物理结构"><a href="#数据的物理结构" class="headerlink" title="数据的物理结构"></a>数据的物理结构</h3><p>指数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</a>在计算机存储空间的存放形式</p><p>数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构</p><p>数据元素的机内表示（映像方法）： 用二进制位（bit）的位串表示数据元素。通常称这种位串为节点（node）。当数据元素有若干个数据项组成时，位串中与各个数据项对应的子位串称为数据域（data field）。因此，节点是数据元素的机内表示（或机内映像）</p><p>关系的机内表示（映像方法）：数据元素之间的关系的机内表示可以分为顺序映像和非顺序映像，常用两种存储结构：顺序存储结构和链式存储结构。顺序映像借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。非顺序映像借助指示元素存储位置的指针（pointer）来表示数据元素之间的逻辑关系</p><h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。一般来说，一种数据结构的逻辑结构根据需要可以表示成多种存储结构，常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等</p><p>数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括线性结构和非线性结构两类</p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>简单地说，线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：</p><p>1、线性结构是非空集</p><p>2、线性结构有且仅有一个开始结点和一个终端结点</p><p>3、线性结构所有结点都最多只有一个直接前趋结点和一个直接后继结点</p><p>线性表就是典型的线性结构，还有栈、队列和串等都属于线性结构</p><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>简单地说，非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点：</p><p>1、非线性结构是非空集</p><p>2、非线性结构的一个结点可能有多个直接前趋结点和多个直接后继结点</p><p>在实际应用中，数组、广义表、树结构和图结构等数据结构都属于非线性结构</p><h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132">计算机科学</a>的发展过程中，数据结构也随之发展。程序设计中常用的数据结构包括如下几个</p><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p><a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式</p><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈( Stack)"></a>栈( Stack)</h3><p><a href="https://baike.baidu.com/item/%E6%A0%88/12808149">栈</a>是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081">线性表</a>，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈</p><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p><a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">队列</a>和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列</p><h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表( Linked List)"></a>链表( Linked List)</h3><p><a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473">链表</a>是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的</p><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树( Tree)"></a>树( Tree)</h3><p><a href="https://baike.baidu.com/item/%E6%A0%91/2699484">树</a>是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0</p><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p><a href="https://baike.baidu.com/item/%E5%9B%BE/13018767">图</a>是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p><a href="https://baike.baidu.com/item/%E5%A0%86/20606834">堆</a>是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构</p><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列表源自于<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录</p><hr><p><strong>注：以上内容来自<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=kg_qa">百度百科</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的&lt;a href=&quot;https://baike.bai</summary>
      
    
    
    
    <category term="数据结构" scheme="https://i-fire.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://i-fire.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
